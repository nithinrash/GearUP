<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1565C0">
    <title>Quiz Wheel Gear Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #1E88E5, #1565C0);
            font-family: 'Inter', sans-serif;
            user-select: none;
            /* Prevent text selection */
        }

        /* Utility for centering absolute items */
        .center-abs {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 3D Sticker Effect Class */
        .sticker-3d {
            box-shadow:
                0px 10px 20px rgba(0, 0, 0, 0.15),
                inset 0px -4px 0px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        /* Flag Pill Styles */
        .flag-pill {
            position: absolute;
            background: linear-gradient(to bottom, #FFFFFF, #F6FAFF);
            border: 3px solid rgba(13, 71, 161, 0.85);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            white-space: nowrap;
            pointer-events: none;
            transform-origin: center center;
            z-index: 20;
        }

        .flag-text {
            color: #0B2A6E;
            font-weight: 700;
            font-size: 13px;
        }

        .flag-emoji {
            font-size: 24px;
        }

        /* Question Panel */
        .question-panel {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.5));
            border: 3px solid #64B5F6;
            backdrop-filter: blur(4px);
        }

        /* Selection Box Animation */
        #selection-box {
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none;
            /* Hidden by default */
        }

        /* Overlay Slide Animation */
        #overlay-container {
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateY(-100%);
        }

        .slide-in {
            transform: translateY(0%) !important;
        }

        /* Mobile-First Phone App Optimizations */
        html,
        body {
            width: 100%;
            height: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        /* Phone-specific flag pills */
        @media (max-width: 480px) {
            .flag-pill {
                padding: 2px 4px;
                border-width: 2px;
                border-radius: 6px;
            }

            .flag-pill img {
                width: 20px !important;
            }
        }

        @media (max-width: 768px) {
            .flag-pill {
                padding: 3px 5px;
            }

            .flag-pill img {
                width: 24px !important;
            }

            #q-panel {
                max-width: 45vw;
                padding: 6px 10px;
                top: 8px !important;
                left: 8px !important;
                border-radius: 12px;
            }

            #q-text {
                font-size: 10px;
                line-height: 1.3;
            }

            #hint-box {
                top: 10px !important;
                font-size: 9px;
            }

            #hint-box>div {
                padding: 4px 8px;
            }

            #score-panel {
                top: 8px !important;
                right: 8px !important;
            }

            #score-panel>div {
                padding: 6px 12px !important;
                border-width: 2px !important;
            }

            #score-display {
                font-size: 18px !important;
            }

            #overlay-emoji {
                font-size: 60px !important;
            }

            #overlay-msg {
                font-size: 32px !important;
            }

            #overlay-details {
                max-width: 90vw;
                padding: 12px;
            }
        }

        /* Very small phones */
        @media (max-width: 360px) {
            #q-panel {
                max-width: 40vw;
                padding: 4px 6px;
            }

            #q-text {
                font-size: 9px;
            }

            .flag-pill img {
                width: 16px !important;
            }
        }

        /* Always allow portrait mode on phones */
        #rotate-message {
            display: none;
        }
    </style>
</head>

<body class="bg-gray-100 overflow-hidden select-none m-0 p-0 font-['Inter']">

    <!-- Landscape Warning Overlay -->
    <div id="rotate-message"
        class="fixed inset-0 z-[99999] bg-[#1565C0] flex flex-col items-center justify-center text-white">
        <div class="text-6xl mb-6 animate-bounce">üì±üîÑ</div>
        <div class="text-3xl font-black text-center px-8">PLEASE ROTATE DEVICE</div>
        <p class="mt-4 text-white/80">This game works best in Landscape Mode</p>
    </div>

    <!-- Main Game Container -->
    <div id="game-container" class="relative w-full h-full bg-gradient-to-b from-[#1E88E5] to-[#1565C0]">

        <div id="background-decor" class="absolute inset-0 z-0 pointer-events-none overflow-hidden">
        </div>

        <canvas id="gameCanvas" class="absolute inset-0 z-10"></canvas>

        <div id="ui-layer" class="absolute inset-0 z-20 pointer-events-none">
            <div id="flags-container" class="absolute inset-0 w-full h-full transition-opacity duration-500"
                style="opacity: 0;">
            </div>

            <div id="selection-box" class="absolute z-50"></div>

            <div id="hint-box" class="absolute top-20 left-1/2 -translate-x-1/2 pointer-events-auto">
                <div
                    class="bg-gradient-to-r from-[#1976D2] to-[#64B5F6] border-2 border-white/70 rounded-2xl shadow-lg px-5 py-2">
                    <p class="text-white text-sm font-bold whitespace-nowrap">Rotate wheel (A/D) ‚Ä¢ Select (S) ‚Ä¢ Reset
                        (W)
                    </p>
                </div>
            </div>
        </div>

        <div id="overlay-container" class="fixed inset-0 z-50 bg-[#1565C0]/90 flex items-center justify-center">
            <div class="text-center transform -translate-y-12">
                <div id="overlay-emoji" class="text-9xl mb-4">üëè</div>
                <div id="overlay-msg" class="text-6xl font-black text-white tracking-widest mb-8">CORRECT</div>

                <div id="overlay-details"
                    class="bg-gradient-to-b from-white/95 to-[#E3F2FD]/90 border-4 border-white/75 rounded-3xl p-6 shadow-2xl max-w-2xl mx-auto text-left hidden">
                    <div class="mb-4">
                        <div class="text-[#0D47A1] text-sm font-bold uppercase">Question</div>
                        <div id="overlay-q" class="text-[#072B4F] text-xl font-semibold mt-1"></div>
                    </div>
                    <div>
                        <div class="text-[#1B5E20] text-sm font-bold uppercase">Answer</div>
                        <div id="overlay-a" class="text-[#2E7D32] text-2xl font-black mt-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- TUTORIAL OVERLAY -->
    <div id="tutorial-overlay" class="fixed inset-0 z-[100] pointer-events-auto">
        <!-- Phase 1: Initial rotation tutorial -->
        <div id="tutorial-phase1" class="absolute inset-0 flex items-center justify-center">
            <!-- Curved arrow left -->
            <div id="arrow-left" class="absolute animate-pulse" style="opacity: 0;">
                <svg width="80" height="80" viewBox="0 0 80 80" fill="none">
                    <path d="M60 50 Q40 20 20 50" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" />
                    <polygon points="15,45 20,55 28,48" fill="white" />
                </svg>
            </div>
            <!-- Curved arrow right -->
            <div id="arrow-right" class="absolute animate-pulse" style="opacity: 0;">
                <svg width="80" height="80" viewBox="0 0 80 80" fill="none">
                    <path d="M20 50 Q40 20 60 50" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" />
                    <polygon points="65,45 60,55 52,48" fill="white" />
                </svg>
            </div>
            <!-- Tap instruction -->
            <div id="tap-hint" class="absolute text-center" style="opacity: 0;">
                <div class="bg-black/60 backdrop-blur-sm rounded-2xl px-6 py-4 text-white animate-bounce">
                    <div class="text-3xl mb-2">üëÜ</div>
                    <div class="text-lg font-bold">TAP TO SELECT</div>
                    <div class="text-sm opacity-80">Rotate wheel with swipe</div>
                </div>
            </div>
        </div>
        <!-- Phase 2: Outer wheel tutorial -->
        <div id="tutorial-phase2" class="absolute inset-0 hidden">
            <div id="match-hint" class="absolute text-center" style="opacity: 0;">
                <div class="bg-black/60 backdrop-blur-sm rounded-2xl px-6 py-4 text-white">
                    <div class="text-2xl mb-2">üéØ</div>
                    <div class="text-lg font-bold">MATCH Q & A</div>
                    <div class="text-sm opacity-80 mt-2">
                        <span class="inline-block px-2 py-1 bg-white/20 rounded">1 Tap = Confirm</span>
                        <span class="inline-block px-2 py-1 bg-white/20 rounded ml-2">2 Taps = Home</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="absolute top-4 left-4 max-w-xs p-4 rounded-2xl shadow-lg question-panel pointer-events-auto transition-opacity duration-500"
        id="q-panel">
        <div id="q-text" class="text-[#072B4F] text-sm font-semibold leading-tight">Rotate wheel...</div>
        <div id="a-text" class="text-[#0D47A1] text-base font-bold mt-2 hidden"></div>
    </div>

    <div id="score-panel" class="absolute top-6 right-6 hidden pointer-events-auto">
        <div
            class="bg-gradient-to-r from-[#FF6B6B] to-[#FF5252] border-4 border-[#8B0000] rounded-2xl shadow-xl px-6 py-3 text-center">
            <div class="text-[#FFF59D] text-xs font-black tracking-widest uppercase">Score</div>
            <div id="score-display" class="text-white text-3xl font-black">0/0</div>
        </div>
    </div>

    <div id="hint-box" class="absolute top-20 left-1/2 -translate-x-1/2 pointer-events-auto">
        <div
            class="bg-gradient-to-r from-[#1976D2] to-[#64B5F6] border-2 border-white/70 rounded-2xl shadow-lg px-5 py-2">
            <div class="text-white text-sm font-bold shadow-sm">Rotate to pick Question, Click Question or Press 'S'
            </div>
        </div>
    </div>
    </div> <!-- End Game Container -->

    <script>
        /* ===========================
           DATA & CONFIG
           =========================== */

        let CONFIG = null;

        const RING_TEETH = 24;
        const GEAR_TEETH = 16;
        const GEAR_STEP = 360 / GEAR_TEETH;
        const RING_STEP = 360 / RING_TEETH;

        // Game State
        let state = {
            gearAngle: 0,
            ringAngle: 0,
            gearTick: 0,
            ringTick: 0,
            gearIndex: 0,
            ringIndex: 0,
            roundStarted: false,
            canSubmit: false,
            score: 0,
            attempts: 0,
            selectedInnerIdx: null,
            targetGearAngle: 0,
            targetRingAngle: 0,

            // Zoom / Focus State
            zoom: 1.5,        // Start zoomed in
            targetZoom: 1.5,
            ringOpacity: 0,   // Start hidden
            targetRingOpacity: 0,

            // Tutorial state
            tutorialShown: false,
            tutorialPhase: 1
        };

        // Double-tap detection
        let lastTapTime = 0;
        const DOUBLE_TAP_DELAY = 300; // ms

        // Mappings
        let countryToQ = {};
        let countryToA = {};
        let innerItems = [];
        let outerItems = [];

        /* ===========================
           CANVAS & RENDERING
           =========================== */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, minDim;
        let centerX, centerY;
        let scaleFactor = 1; // Not used but good to have

        // Geometry Cache
        let geom = {
            ringOuterR: 0, ringRootR: 0, ringTipR: 0,
            gearRootR: 0, gearTipR: 0,
            gearCenter: { x: 0, y: 0 },
            ringCenter: { x: 0, y: 0 }
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            minDim = Math.min(width, height);
            centerX = width / 2;
            centerY = height / 2;

            // Calculate Gear Geometry
            geom.ringOuterR = minDim * 0.48;
            const ringBandW = minDim * 0.07;
            geom.ringRootR = geom.ringOuterR - ringBandW;
            const toothH = minDim * 0.06;
            geom.ringTipR = geom.ringRootR - toothH - (minDim * 0.0075); // mesh tightness

            const ringPitchR = geom.ringRootR - toothH / 2;
            const gearPitchR = ringPitchR * (2 / 3); // 16/24 ratio

            geom.gearRootR = gearPitchR - toothH / 2;
            geom.gearTipR = gearPitchR + toothH / 2 + (minDim * 0.0075);

            const centerOffset = ringPitchR - gearPitchR;
            // Contact angle 0 degrees (Right side)
            const contactRad = 0;

            geom.ringCenter = { x: centerX, y: centerY };
            geom.gearCenter = {
                x: centerX + centerOffset * Math.cos(contactRad),
                y: centerY + centerOffset * Math.sin(contactRad)
            };

            render();
            updateDomElements(); // Update HTML overlay positions
        }

        window.addEventListener('resize', resize);

        /* ===========================
           ANIMATION LOOP
           =========================== */
        function lerp(start, end, t) { return start * (1 - t) + end * t; }

        let lastTime = 0;
        function loop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Spring/Lerp Physics
            state.gearAngle += (state.targetGearAngle - state.gearAngle) * 0.1;
            state.ringAngle += (state.targetRingAngle - state.ringAngle) * 0.1;

            // Zoom & Opacity Animation
            state.zoom += (state.targetZoom - state.zoom) * 0.05;
            state.ringOpacity += (state.targetRingOpacity - state.ringOpacity) * 0.05;

            render();
            updateUiLogic();
            updateDomElements();

            requestAnimationFrame(loop);
        }

        // ... (Draw functions)
        function polar(r, theta) {
            return { x: r * Math.cos(theta), y: r * Math.sin(theta) };
        }

        function drawExternalGearPath(ctx, cx, cy, rRoot, rTip, numTeeth) {
            const step = (Math.PI * 2) / numTeeth;
            const halfStep = step / 2;

            // Simplistic Involute approximation
            // Tooth thickness at pitch line ~ half pitch
            const toothWidthAng = halfStep * 0.5;

            ctx.beginPath();
            for (let i = 0; i < numTeeth; i++) {
                const theta = i * step;
                // Root
                ctx.arc(cx, cy, rRoot, theta - halfStep / 2 + 0.05, theta + halfStep / 2 - 0.05);

                // Tooth Up
                const p1 = polar(rRoot, theta + halfStep / 2 - 0.05);
                const p2 = polar(rTip, theta + halfStep / 2 + 0.05);
                const p3 = polar(rTip, theta + step - halfStep / 2 - 0.05);
                const p4 = polar(rRoot, theta + step - halfStep / 2 + 0.05);

                ctx.lineTo(p2.x, p2.y);
                ctx.arc(cx, cy, rTip, theta + halfStep / 2 + 0.05, theta + step - halfStep / 2 - 0.05);
                ctx.lineTo(p4.x, p4.y);
            }
            ctx.closePath();
        }

        function drawInternalTooth(ctx, cx, cy, rRoot, rTip, numTeeth) {
            // For internal gear (ring), teeth point INWARDS - THICK GEAR TEETH
            // Matching Kotlin's buildSingleInternalTooth with rounded corners

            const toothH = rRoot - rTip;
            const pitch = (2 * Math.PI) / numTeeth;
            const topFrac = 0.42; // tooth top width fraction
            const top = pitch * topFrac;
            const flank = (pitch - top) / 2;

            // Tooth dimensions - THICKER teeth
            const baseWidth = minDim * 0.035;  // Wide base
            const tipWidth = minDim * 0.018;   // Narrower tip

            // Rounded fillet radii
            const rootFillet = toothH * 0.15;
            const tipRound = toothH * 0.12;

            ctx.beginPath();
            // Start at bottom-left of tooth base
            ctx.moveTo(rRoot, -baseWidth);

            // Left flank with curve to tip
            ctx.quadraticCurveTo(
                rRoot - toothH * 0.3, -baseWidth * 0.7,
                rTip + tipRound, -tipWidth
            );

            // Tip (rounded)
            ctx.lineTo(rTip + tipRound, tipWidth);

            // Right flank with curve to base
            ctx.quadraticCurveTo(
                rRoot - toothH * 0.3, baseWidth * 0.7,
                rRoot, baseWidth
            );

            ctx.closePath();
        }

        function render() {
            if (!CONFIG) return;

            ctx.clearRect(0, 0, width, height);

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(state.zoom, state.zoom);
            ctx.translate(-centerX, -centerY);

            // 1. Draw Outer Ring (Fade in)
            if (state.ringOpacity > 0.01) {
                ctx.globalAlpha = state.ringOpacity;

                ctx.save();
                ctx.translate(centerX, centerY);

                // Ring Body
                ctx.beginPath();
                ctx.arc(0, 0, geom.ringOuterR, 0, Math.PI * 2);
                ctx.arc(0, 0, geom.ringRootR, 0, Math.PI * 2, true);
                const grad = ctx.createLinearGradient(-geom.ringOuterR, -geom.ringOuterR, geom.ringOuterR, geom.ringOuterR);
                grad.addColorStop(0, '#2E65B8');
                grad.addColorStop(0.5, '#8AC7FF');
                grad.addColorStop(1, '#1E56A8');
                ctx.fillStyle = grad;
                ctx.fill();

                // Internal Teeth (Ring)
                // Use rotOffset for mesh
                const ringStepRad = (2 * Math.PI) / RING_TEETH;
                // Correct mesh: Ring angle + offset. 
                // We want 0-deg contact to be mesh point?
                // The previous logic had 10-deg contact.
                // Let's stick to standard math: active contact is at 0 (Right).

                const rotOffset = (state.ringAngle + RING_STEP / 2) * (Math.PI / 180);

                ctx.fillStyle = '#1565C0';
                for (let i = 0; i < RING_TEETH; i++) {
                    const theta = i * ringStepRad + rotOffset;
                    ctx.save();
                    ctx.rotate(theta);
                    drawInternalTooth(ctx, 0, 0, geom.ringRootR, geom.ringTipR, RING_TEETH);
                    ctx.fillStyle = '#1565C0';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = minDim * 0.002;
                    ctx.stroke();
                    ctx.restore();
                }

                // Bolts
                ctx.fillStyle = '#B0C9DC';
                for (let i = 0; i < 12; i++) {
                    const a = (i * 30) * (Math.PI / 180);
                    const r = (geom.ringOuterR + geom.ringRootR) / 2;
                    ctx.beginPath();
                    ctx.arc(r * Math.cos(a), r * Math.sin(a), minDim * 0.005, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }

            // 2. Draw Inner Gear
            // Gear Center: Previously offset for 10deg contact. Now we want Right Side (0deg)
            // But if we want the gear centered on screen when zoomed... 
            // The logic: geom.gearCenter is fixed.
            // If we want zoom focus on the gear, we scale around the center.

            ctx.save();
            ctx.translate(geom.gearCenter.x, geom.gearCenter.y);
            ctx.rotate(state.gearAngle * (Math.PI / 180));

            // Shadow
            ctx.save();
            ctx.translate(minDim * 0.005, minDim * 0.005);
            drawExternalGearPath(ctx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();
            ctx.restore();

            // Gear Body
            drawExternalGearPath(ctx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            const gearGrad = ctx.createRadialGradient(0, 0, geom.gearRootR * 0.5, 0, 0, geom.gearTipR);
            gearGrad.addColorStop(0, '#FFE082');
            gearGrad.addColorStop(1, '#FF8F00');
            ctx.fillStyle = gearGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.45)';
            ctx.lineWidth = minDim * 0.003;
            ctx.stroke();

            // Inner Hub (Grey) - CLICKABLE
            const boreR = geom.gearRootR * 0.55;
            ctx.beginPath();
            ctx.arc(0, 0, boreR, 0, Math.PI * 2);
            const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, boreR);
            // Highlight hub when ready to click?
            if (!state.roundStarted && state.zoom > 1.2) {
                hubGrad.addColorStop(0, '#B0BEC5'); // Lighter
                hubGrad.addColorStop(1, '#546E7A');
            } else {
                hubGrad.addColorStop(0, '#95A5AE');
                hubGrad.addColorStop(1, '#3A454B');
            }
            ctx.fillStyle = hubGrad;
            ctx.fill();

            // Hub Text "TAP" if zoomed
            const hubIsMobile = minDim < 500;
            if (!state.roundStarted && state.zoom > 1.2) {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.035 : 0.04)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("TAP", 0, -minDim * 0.01);
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.016 : 0.02)}px Inter`;
                ctx.fillText("TO SELECT", 0, minDim * 0.025);
            } else if (state.roundStarted) {
                // Show tap instructions when outer wheel is visible
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.018 : 0.022)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("1√ó CHECK", 0, -minDim * 0.018);
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.015 : 0.018)}px Inter`;
                ctx.fillStyle = 'rgba(255,200,200,0.9)';
                ctx.fillText("2√ó HOME", 0, minDim * 0.015);
            } else {
                // Bolts normally
                ctx.fillStyle = '#263238';
                for (let k = 0; k < 6; k++) {
                    const a = (k * 60) * (Math.PI / 180);
                    const bx = boreR * 0.7 * Math.cos(a);
                    const by = boreR * 0.7 * Math.sin(a);
                    ctx.beginPath();
                    ctx.arc(bx, by, minDim * 0.006, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 3. Draw Inner Text
            // ... (Text drawing logic same, just change angle offset if needed?)
            // We want text readable at 0 degrees (Right)

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Mobile-optimized font size - scales down on smaller screens
            const isMobile = minDim < 500;
            const baseFontSize = isMobile ? Math.max(8, minDim * 0.018) : Math.max(12, minDim * 0.022);
            const textR = geom.gearRootR * (isMobile ? 0.78 : 0.82);
            const gearStepRad = (2 * Math.PI) / GEAR_TEETH;

            // Find the 5 rightmost indices for inner gear (closest to 0 degrees)
            function getInnerRightmost5() {
                const indices = [];
                for (let i = 0; i < GEAR_TEETH; i++) {
                    const angleDeg = (state.gearAngle + i * (360 / GEAR_TEETH)) % 360;
                    let normAngle = angleDeg;
                    if (normAngle > 180) normAngle -= 360;
                    if (normAngle < -180) normAngle += 360;
                    indices.push({ idx: i, angle: Math.abs(normAngle) });
                }
                // Sort by closest to 0 (right side)
                indices.sort((a, b) => a.angle - b.angle);
                return new Map(indices.slice(0, 5).map((x, rank) => [x.idx, rank]));
            }

            const innerRightmost5 = getInnerRightmost5();

            innerItems.forEach((label, i) => {
                const theta = i * gearStepRad;
                const x = textR * Math.cos(theta);
                const y = textR * Math.sin(theta);

                // Check if this item is in the rightmost 5
                const rank = innerRightmost5.get(i);
                let sizeMultiplier = 1.0;
                if (rank !== undefined) {
                    // Rank 0 = closest to right (biggest), rank 4 = 5th closest (smaller boost)
                    // Reduced scaling for mobile to fit text properly
                    const maxScale = isMobile ? 1.25 : 1.4;
                    const scaleStep = isMobile ? 0.05 : 0.075;
                    sizeMultiplier = maxScale - (rank * scaleStep);
                }

                const fontSize = baseFontSize * sizeMultiplier;
                ctx.font = `bold ${fontSize}px Inter`;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(theta);

                const globalDeg = (state.gearAngle + (i * 360 / GEAR_TEETH)) % 360;
                let normDeg = globalDeg < 0 ? globalDeg + 360 : globalDeg;

                // Flip logic for readability
                if (normDeg > 90 && normDeg < 270) {
                    ctx.rotate(Math.PI);
                }

                // Add slight stroke for visibility on enlarged items
                if (rank !== undefined && rank < 3) {
                    ctx.strokeStyle = 'rgba(192, 192, 192, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.strokeText(label, 0, 0);
                }

                ctx.fillStyle = '#003366';
                ctx.fillText(label, 0, 0);
                ctx.restore();
            });

            ctx.restore(); // End Gear

            ctx.restore(); // End Zoom Scale
        }

        // ... updateDomElements (Uses state.zoom to scale positions?)
        // Actually, CSS transform for HTML elements (Pills) needs to handle zoom?
        // Or we just zoom the canvas and keep HTML elements on top?
        // If we zoom canvas, the coordinate system changes.
        // We probably need to apply zoom to DOM element positions too.

        function updateDomElements() {
            if (!minDim) return;

            // Update flags container opacity to match ring opacity
            const flagsContainer = document.getElementById('flags-container');
            if (flagsContainer) {
                flagsContainer.style.opacity = state.ringOpacity;
            }

            // Background Stickers (Parallax or static? Static for now)
            // ...

            // Flag Pills - need to match zoomed coordinate system?
            // If canvas is scaled via ctx.scale, visual is zoomed.
            // HTML elements are independent.
            // We must project the zoomed coordinates to screen coordinates.

            // Scale center: centerX, centerY
            // ScreenX = centerX + (WorldX - centerX) * zoom
            // ScreenY = centerY + (WorldY - centerY) * zoom

            // Position flags on the outer ring band (middle of the ring)
            const radius = (geom.ringOuterR + geom.ringRootR) / 2;
            const ringPitch = (2 * Math.PI) / RING_TEETH;
            const phaseOffset = (state.ringAngle + RING_STEP / 2 + 4 + RING_STEP / 2) * (Math.PI / 180);

            // Find the 5 rightmost indices (closest to 0 degrees / right side)
            function getRightmost5Indices() {
                const indices = [];
                for (let i = 0; i < RING_TEETH; i++) {
                    const theta = i * ringPitch + phaseOffset;
                    const angleDeg = (theta * 180 / Math.PI) % 360;
                    // Normalize to -180 to 180
                    let normAngle = angleDeg;
                    if (normAngle > 180) normAngle -= 360;
                    indices.push({ idx: i, angle: Math.abs(normAngle) });
                }
                // Sort by closest to 0 (right side)
                indices.sort((a, b) => a.angle - b.angle);
                return new Set(indices.slice(0, 5).map(x => x.idx));
            }

            const rightmost5 = getRightmost5Indices();

            flagElements.forEach((el, i) => {
                if (state.ringOpacity < 0.1) {
                    el.style.opacity = '0';
                    return;
                }
                el.style.opacity = state.ringOpacity;

                const theta = i * ringPitch + phaseOffset;
                // World Coords
                const wx = geom.ringCenter.x + radius * Math.cos(theta);
                const wy = geom.ringCenter.y + radius * Math.sin(theta);

                // Screen Coords
                const sx = centerX + (wx - centerX) * state.zoom;
                const sy = centerY + (wy - centerY) * state.zoom;

                el.style.left = sx + 'px';
                el.style.top = sy + 'px';

                // Dynamic sizing - rightmost 5 get progressively bigger based on rank
                const isBig = rightmost5.has(i);
                const baseScale = state.zoom;

                // Get rank (0 = closest to right, 4 = 5th closest)
                let rank = -1;
                if (isBig) {
                    const indices = [];
                    for (let j = 0; j < RING_TEETH; j++) {
                        const t = j * ringPitch + phaseOffset;
                        const aDeg = (t * 180 / Math.PI) % 360;
                        let na = aDeg;
                        if (na > 180) na -= 360;
                        indices.push({ idx: j, angle: Math.abs(na) });
                    }
                    indices.sort((a, b) => a.angle - b.angle);
                    rank = indices.findIndex(x => x.idx === i);
                }

                // Scale: rank 0 = 1.5x, rank 1 = 1.4x, rank 2 = 1.3x, rank 3 = 1.2x, rank 4 = 1.1x
                // Reduced for mobile
                const flagIsMobile = minDim < 500;
                let sizeScale = 1.0;
                if (rank >= 0 && rank < 5) {
                    const maxFlagScale = flagIsMobile ? 1.25 : 1.5;
                    const flagScaleStep = flagIsMobile ? 0.05 : 0.1;
                    sizeScale = maxFlagScale - (rank * flagScaleStep);
                }

                el.style.transform = `translate(-50%, -50%) scale(${baseScale * sizeScale})`;

                // Visual enhancements for bigger flags
                if (rank >= 0 && rank < 3) {
                    el.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 255, 255, 0.2)';
                    el.style.borderWidth = flagIsMobile ? '2px' : '4px';
                } else {
                    el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.2)';
                    el.style.borderWidth = flagIsMobile ? '2px' : '3px';
                }

                // Also adjust the image/content size for the big ones
                const img = el.querySelector('img');
                if (img) {
                    // Gradient image sizes based on rank - smaller for mobile
                    const baseSizes = flagIsMobile ? [28, 25, 23, 21, 19, 18] : [52, 46, 42, 38, 35, 32];
                    const sizeIdx = rank >= 0 && rank < 5 ? rank : 5;
                    img.style.width = baseSizes[sizeIdx] + 'px';
                }
            });
        }

        /* ===========================
           LOGIC updates
           =========================== */
        function updateUiLogic() {
            // Active Item at 0 degrees (Right)
            const contactDeg = 0;
            const gearPitch = 360 / GEAR_TEETH;

            let normGear = state.gearAngle % 360;
            if (normGear < 0) normGear += 360;

            // at 0 deg: angle + i*pitch = 0  => i*pitch = -angle
            // Invert logic:
            // The item at 0 degrees is the one where (i * step + currentAngle) % 360 ~= 0
            // i * step = -currentAngle
            // i = -currentAngle / step

            const rawIdx = (contactDeg - state.gearAngle) / gearPitch;
            let idx = Math.round(rawIdx) % GEAR_TEETH;
            if (idx < 0) idx += GEAR_TEETH;

            const activeItem = innerItems[idx];

            if (!state.roundStarted) {
                // Updating UI
                document.getElementById('q-text').innerText = countryToQ[activeItem] || activeItem;
                state.activeInnerLabel = activeItem;
                state.activeInnerIdx = idx;

                // Selection Box Logic
                // It should be at geom.gearCenter.x + geom.gearRootR, geom.gearCenter.y
                // Scaled by Zoom!

                const box = document.getElementById('selection-box');
                const dist = Math.abs(rawIdx - Math.round(rawIdx));

                if (dist < 0.1) {
                    // Coordinates in World Space
                    const wx = geom.gearCenter.x + geom.gearRootR; // Right edge
                    const wy = geom.gearCenter.y;

                    // To Screen Space
                    const sx = centerX + (wx - centerX) * state.zoom;
                    const sy = centerY + (wy - centerY) * state.zoom;

                    box.style.display = 'block';
                    // Box size also depends on zoom? or fixed UI?
                    // Let's keep it consistent.
                    box.style.width = (160 * state.zoom) + 'px';
                    box.style.height = (60 * state.zoom) + 'px';
                    box.style.left = (sx - (80 * state.zoom)) + 'px'; // Centered on Right Edge? 
                    // Wait, right edge is x+R. Box center should be there?
                    // Or box should contain the text? Text is inside.
                    // Text R = 0.82 * R.
                    // Box should be around 0.85 * R?

                    const textR = geom.gearRootR * 0.88;
                    const tx = geom.gearCenter.x + textR;
                    const screenTx = centerX + (tx - centerX) * state.zoom;

                    box.style.left = (screenTx - (80 * state.zoom)) + 'px';
                    box.style.top = (sy - (30 * state.zoom)) + 'px';

                } else {
                    box.style.display = 'none';
                }
            } else {
                document.getElementById('selection-box').style.display = 'none';
            }
        }

        /* ===========================
           TUTORIAL ANIMATIONS
           =========================== */
        function showInitialTutorial() {
            if (state.tutorialShown) return;

            const overlay = document.getElementById('tutorial-overlay');
            const phase1 = document.getElementById('tutorial-phase1');
            const arrowLeft = document.getElementById('arrow-left');
            const arrowRight = document.getElementById('arrow-right');
            const tapHint = document.getElementById('tap-hint');

            overlay.style.pointerEvents = 'none';
            phase1.classList.remove('hidden');

            // Position arrows around the gear
            const updateArrowPositions = () => {
                const gx = geom.gearCenter.x;
                const gy = geom.gearCenter.y;
                const r = geom.gearTipR * state.zoom * 0.8;

                arrowLeft.style.left = (gx - r - 60) + 'px';
                arrowLeft.style.top = (gy - 40) + 'px';

                arrowRight.style.left = (gx + r - 20) + 'px';
                arrowRight.style.top = (gy - 40) + 'px';

                tapHint.style.left = gx + 'px';
                tapHint.style.top = (gy + r + 30) + 'px';
                tapHint.style.transform = 'translateX(-50%)';
            };

            setTimeout(() => {
                updateArrowPositions();
                // Fade in arrows
                arrowLeft.style.transition = 'opacity 0.5s ease-out';
                arrowRight.style.transition = 'opacity 0.5s ease-out';
                arrowLeft.style.opacity = '1';
                arrowRight.style.opacity = '1';

                // Then show tap hint
                setTimeout(() => {
                    tapHint.style.transition = 'opacity 0.5s ease-out';
                    tapHint.style.opacity = '1';
                }, 800);
            }, 500);
        }

        function showPhase2Tutorial() {
            const phase1 = document.getElementById('tutorial-phase1');
            const phase2 = document.getElementById('tutorial-phase2');
            const matchHint = document.getElementById('match-hint');

            phase1.classList.add('hidden');
            phase2.classList.remove('hidden');

            // Position at center-bottom
            setTimeout(() => {
                matchHint.style.left = '50%';
                matchHint.style.top = '75%';
                matchHint.style.transform = 'translate(-50%, -50%)';
                matchHint.style.transition = 'opacity 0.5s ease-out';
                matchHint.style.opacity = '1';

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    matchHint.style.opacity = '0';
                }, 3000);
            }, 500);
        }

        function hideTutorial() {
            const arrowLeft = document.getElementById('arrow-left');
            const arrowRight = document.getElementById('arrow-right');
            const tapHint = document.getElementById('tap-hint');
            const matchHint = document.getElementById('match-hint');

            [arrowLeft, arrowRight, tapHint, matchHint].forEach(el => {
                if (el) {
                    el.style.transition = 'opacity 0.3s ease-out';
                    el.style.opacity = '0';
                }
            });
        }

        function handleClick(x, y) {
            // Check Hub Click first
            const dx = x - geom.gearCenter.x;
            const dy = y - geom.gearCenter.y;
            const dist = Math.hypot(dx, dy);

            if (dist < geom.gearRootR * 0.55) {
                // Hub Clicked! - Check for double tap
                const now = Date.now();
                const isDoubleTap = (now - lastTapTime) < DOUBLE_TAP_DELAY;
                lastTapTime = now;

                if (!state.roundStarted) {
                    // Phase 1: Single tap to start round
                    // CONFIRM SELECTION -> Start Zoom Out
                    state.roundStarted = true;
                    state.targetZoom = 1.0;          // Zoom Out
                    state.targetRingOpacity = 1.0;   // Fade In Outer
                    state.tutorialPhase = 2;         // Switch to phase 2 tutorial

                    document.getElementById('hint-box').style.opacity = '0';
                    document.getElementById('score-panel').classList.remove('hidden');
                    hideTutorial();
                    showPhase2Tutorial();
                    updateScore();

                    // Recalculate match?
                    state.selectedInnerIdx = state.activeInnerIdx;
                } else {
                    // Round already started - check tap type
                    if (isDoubleTap) {
                        // DOUBLE TAP = RESET (W key - go home)
                        state.roundStarted = false;
                        state.targetZoom = 1.5;
                        state.targetRingOpacity = 0;
                        state.score = 0;
                        state.attempts = 0;
                        state.selectedInnerIdx = null;
                        state.tutorialPhase = 1;
                        updateScore();
                        document.getElementById('hint-box').style.opacity = '1';
                        document.getElementById('score-panel').classList.add('hidden');
                        hideTutorial();
                    } else {
                        // SINGLE TAP = CHECK ANSWER (S key - confirm)
                        checkAnswer();
                    }
                }
                return;
            }

            if (state.roundStarted) return;

            // Text Click Logic (Drag-to-rotate)
            // ... (Existing click logic, updated for 0 deg?)

            const clickAngle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Normalize everything
            let normalizedGearAngle = state.gearAngle % 360;
            if (normalizedGearAngle < 0) normalizedGearAngle += 360;

            let normalizedClick = clickAngle;
            if (normalizedClick < 0) normalizedClick += 360;

            const step = 360 / GEAR_TEETH;
            let targetI = (normalizedClick - normalizedGearAngle) / step;
            let i = Math.round(targetI);
            i = ((i % GEAR_TEETH) + GEAR_TEETH) % GEAR_TEETH;

            if (i >= 0 && i < GEAR_TEETH) {
                rotateToIndex(i);
            }
        }

        function rotateToIndex(idx) {
            // Target: We want item 'idx' to be at 0 DEGREES (Right)
            // i * step + TargetGearAngle = 0
            // TargetGearAngle = -i * step

            const step = 360 / GEAR_TEETH;
            let targetG = -idx * step; // Simple!

            let current = state.gearAngle;
            let diff = targetG - current;
            diff = diff % 360;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;

            state.targetGearAngle = current + diff;
            state.targetRingAngle = state.ringAngle + diff * (2 / 3);
        }

        function snapToGrid() {
            // Optional: Snap to nearest gear tooth alignment
            // Not strictly required but feels nicer.
            const step = 360 / GEAR_TEETH;
            const current = state.gearAngle;
            const remainder = current % step;
            // Snap logic... maybe later if user asks.
        }

        function updateScore() {
            document.getElementById('score-display').innerText = `${state.score}/${state.attempts}`;
        }

        // Get the flag at the active position (rightmost on outer ring)
        function getActiveOuterFlag() {
            const ringPitch = (2 * Math.PI) / RING_TEETH;
            const phaseOffset = (state.ringAngle + RING_STEP / 2 + 4 + RING_STEP / 2) * (Math.PI / 180);

            // Find which flag is closest to 0 degrees (right side)
            let closestIdx = 0;
            let closestAngle = Infinity;

            for (let i = 0; i < RING_TEETH; i++) {
                const theta = i * ringPitch + phaseOffset;
                let angleDeg = (theta * 180 / Math.PI) % 360;
                if (angleDeg > 180) angleDeg -= 360;
                if (angleDeg < -180) angleDeg += 360;

                if (Math.abs(angleDeg) < closestAngle) {
                    closestAngle = Math.abs(angleDeg);
                    closestIdx = i;
                }
            }

            return outerItems[closestIdx] || '';
        }

        // Show overlay slide animation (like Kotlin's OverlaySlide)
        function showOverlay(isCorrect, question, answer) {
            const overlay = document.getElementById('overlay-container');
            const emoji = document.getElementById('overlay-emoji');
            const msg = document.getElementById('overlay-msg');
            const details = document.getElementById('overlay-details');
            const qText = document.getElementById('overlay-q');
            const aText = document.getElementById('overlay-a');

            // Set content
            emoji.innerText = isCorrect ? 'üëè' : 'üò•';
            msg.innerText = isCorrect ? 'CORRECT' : 'TRY AGAIN';
            msg.style.color = isCorrect ? '#4CAF50' : '#FF5252';

            if (question || answer) {
                details.classList.remove('hidden');
                qText.innerText = question || '';
                aText.innerText = answer || '';
                aText.style.color = isCorrect ? '#2E7D32' : '#B71C1C';
            } else {
                details.classList.add('hidden');
            }

            // Slide in
            overlay.classList.add('slide-in');

            // Slide out after delay
            setTimeout(() => {
                overlay.classList.remove('slide-in');
            }, 1500);
        }

        // Check answer and show result
        function checkAnswer() {
            if (!state.roundStarted) return;

            const innerLabel = state.activeInnerLabel;
            const expectedFlag = countryToA[innerLabel];
            const selectedFlag = getActiveOuterFlag();

            const isCorrect = expectedFlag === selectedFlag;

            state.attempts++;
            if (isCorrect) state.score++;
            updateScore();

            const question = countryToQ[innerLabel] || innerLabel;
            const answer = expectedFlag || selectedFlag;

            showOverlay(isCorrect, question, answer);
        }

        let flagElements = [];

        // Convert flag emoji to country code (e.g., "üáÆüá≥" -> "in")
        function flagEmojiToCountryCode(flag) {
            if (!flag || flag.length < 2) return null;
            const codePoints = [...flag].map(c => c.codePointAt(0));
            // Regional indicator symbols are in range 0x1F1E6-0x1F1FF (A-Z)
            const letters = codePoints
                .filter(cp => cp >= 0x1F1E6 && cp <= 0x1F1FF)
                .map(cp => String.fromCharCode(cp - 0x1F1E6 + 65));
            if (letters.length === 2) {
                return letters.join('').toLowerCase();
            }
            return null;
        }

        function createFlagPills() {
            const container = document.getElementById('flags-container');
            container.innerHTML = '';
            flagElements = [];

            outerItems.forEach((flag, i) => {
                const el = document.createElement('div');
                el.className = 'flag-pill';

                // Try to convert emoji to country code and use flag image
                const countryCode = flagEmojiToCountryCode(flag);
                if (countryCode) {
                    el.innerHTML = `<img src="https://flagcdn.com/w40/${countryCode}.png" alt="${flag}" style="width: 32px; height: auto; border-radius: 3px;">`;
                } else {
                    // Fallback to emoji if conversion fails
                    el.innerHTML = `<span class="flag-emoji">${flag}</span>`;
                }

                container.appendChild(el);
                flagElements.push(el);
            });
        }

        function initInteraction() {
            let isDragging = false;
            let lastX = 0, lastY = 0;

            const handleStart = (x, y) => {
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;
                if (Math.hypot(dx, dy) < geom.gearTipR * 1.2) {
                    isDragging = true;
                    lastX = x;
                    lastY = y;
                    handleClick(x, y);
                }
            };

            const handleMove = (x, y) => {
                if (!isDragging) return;
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;
                const angle = Math.atan2(dy, dx);

                const prevA = Math.atan2(lastY - geom.gearCenter.y, lastX - geom.gearCenter.x);
                let delta = angle - prevA;

                if (delta > Math.PI) delta -= Math.PI * 2;
                if (delta < -Math.PI) delta += Math.PI * 2;

                // Apply rotation
                state.targetGearAngle += delta * (180 / Math.PI);
                state.targetRingAngle += delta * (180 / Math.PI) * (2 / 3);

                lastX = x;
                lastY = y;
            };

            const handleEnd = () => { isDragging = false; };

            canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', e => {
                if (e.touches.length > 1) return;
                const t = e.touches[0];
                handleStart(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchmove', e => {
                if (!isDragging) return;
                e.preventDefault();
                const t = e.touches[0];
                handleMove(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchend', handleEnd);

            // Key Controls
            window.addEventListener('keydown', e => {
                const step = 360 / GEAR_TEETH;
                if (e.key === 'ArrowRight' || e.key === 'd') {
                    state.targetGearAngle -= step;
                    state.targetRingAngle -= step * 0.666;
                }
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    state.targetGearAngle += step;
                    state.targetRingAngle += step * 0.666;
                }
                if (e.key === 's' || e.key === ' ') {
                    if (!state.roundStarted) {
                        // Start round - simulate hub click
                        handleClick(geom.gearCenter.x, geom.gearCenter.y);
                    } else {
                        // Check answer
                        checkAnswer();
                    }
                }
                if (e.key === 'w') {
                    // Reset to initial state
                    state.roundStarted = false;
                    state.targetZoom = 1.5;
                    state.targetRingOpacity = 0;
                    state.score = 0;
                    state.attempts = 0;
                    state.selectedInnerIdx = null;
                    updateScore();
                    document.getElementById('hint-box').style.opacity = '1';
                    document.getElementById('score-panel').classList.add('hidden');
                }
            });
        }

        // Init
        async function initGame() {
            initInteraction(); // Enable controls
            createBackgroundStickers(); // Add emoji decorations like Kotlin
            try {
                const response = await fetch('flags.json');
                CONFIG = await response.json();

                // Initialize Mappings
                countryToQ = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.question]));
                countryToA = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.answer]));
                innerItems = CONFIG.innerOrder;

                // Pad outer flags
                outerItems = [...CONFIG.outerFlags];
                while (outerItems.length < RING_TEETH) outerItems.push("");
                outerItems = outerItems.slice(0, RING_TEETH);

                // Initialize DOM pills
                createFlagPills();

                // Start
                resize();
                requestAnimationFrame(loop);

                // Show tutorial after a brief delay
                setTimeout(() => {
                    showInitialTutorial();
                }, 1000);
            } catch (error) {
                console.error("Failed to load game configuration:", error);
                document.getElementById('q-text').innerText = "Error loading game data.";
            }
        }

        // Background decorations like Kotlin's BackgroundDecorStatic
        function createBackgroundStickers() {
            const container = document.getElementById('background-decor');
            if (!container) return;

            const stickers = [
                { emoji: 'üìö', angle: 350, radius: 0.57, size: 70, c1: '#7B61FF', c2: '#4D8AFF', rot: -6 },
                { emoji: '‚úèÔ∏è', angle: 20, radius: 0.55, size: 60, c1: '#FFA24C', c2: '#FFC35B', rot: 8 },
                { emoji: 'üß™', angle: 65, radius: 0.58, size: 65, c1: '#33D1B1', c2: '#1CB5E0', rot: -4 },
                { emoji: 'ü™™', angle: 110, radius: 0.56, size: 66, c1: '#58C9F3', c2: '#2D9CDB', rot: 5 },
                { emoji: 'üåé', angle: 155, radius: 0.60, size: 75, c1: '#6EE7F9', c2: '#22D3EE', rot: 0 },
                { emoji: '‚≠ê', angle: 200, radius: 0.55, size: 56, c1: '#FFC35B', c2: '#FF9E9E', rot: -10 },
                { emoji: 'üéí', angle: 245, radius: 0.58, size: 64, c1: '#FB7A7A', c2: '#FF9E9E', rot: 6 },
                { emoji: 'üß©', angle: 290, radius: 0.56, size: 60, c1: '#6EE7A8', c2: '#34D399', rot: -3 }
            ];

            stickers.forEach(s => {
                const el = document.createElement('div');
                el.style.cssText = `
                    position: absolute;
                    width: ${s.size}px;
                    height: ${s.size}px;
                    background: linear-gradient(135deg, ${s.c1}, ${s.c2});
                    border-radius: 16px;
                    border: 3px solid rgba(255, 255, 255, 0.55);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: ${s.size * 0.45}px;
                    transform: rotate(${s.rot}deg);
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.1);
                    pointer-events: none;
                `;
                el.innerText = s.emoji;
                el.dataset.angle = s.angle;
                el.dataset.radius = s.radius;
                container.appendChild(el);
            });

            // Position stickers on resize
            function positionStickers() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const minD = Math.min(w, h);
                const cx = w / 2;
                const cy = h / 2;

                container.querySelectorAll('div').forEach(el => {
                    const angle = parseFloat(el.dataset.angle) * (Math.PI / 180);
                    const radius = parseFloat(el.dataset.radius) * minD;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    el.style.left = (x - el.offsetWidth / 2) + 'px';
                    el.style.top = (y - el.offsetHeight / 2) + 'px';
                });
            }

            positionStickers();
            window.addEventListener('resize', positionStickers);
        }

        initGame();
    </script>
</body>

</html>
