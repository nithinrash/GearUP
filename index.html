<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1565C0">
    <title>Quiz Wheel Gear Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #1E88E5, #1565C0);
            font-family: 'Inter', sans-serif;
            user-select: none;
            /* Prevent text selection */
        }

        /* Utility for centering absolute items */
        .center-abs {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 3D Sticker Effect Class */
        .sticker-3d {
            box-shadow:
                0px 10px 20px rgba(0, 0, 0, 0.15),
                inset 0px -4px 0px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        /* Flag Pill Styles */
        .flag-pill {
            position: absolute;
            background: linear-gradient(to bottom, #FFFFFF, #F6FAFF);
            border: 3px solid rgba(13, 71, 161, 0.85);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            white-space: nowrap;
            pointer-events: none;
            transform-origin: center center;
            z-index: 20;
        }

        .flag-text {
            color: #0B2A6E;
            font-weight: 700;
            font-size: 13px;
        }

        .flag-emoji {
            font-size: 24px;
        }

        /* Question Panel */
        .question-panel {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.5));
            border: 3px solid #64B5F6;
            backdrop-filter: blur(4px);
        }

        /* Selection Box Animation */
        #selection-box {
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none;
            /* Hidden by default */
        }

        /* Overlay Slide Animation */
        #overlay-container {
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateY(-100%);
        }

        .slide-in {
            transform: translateY(0%) !important;
        }

        /* Mobile-First Phone App Optimizations */
        html,
        body {
            width: 100%;
            height: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        /* Phone-specific flag pills */
        @media (max-width: 480px) {
            .flag-pill {
                padding: 2px 4px;
                border-width: 2px;
                border-radius: 6px;
            }

            .flag-pill img {
                width: 20px !important;
            }
        }

        @media (max-width: 768px) {
            .flag-pill {
                padding: 3px 5px;
            }

            .flag-pill img {
                width: 24px !important;
            }

            #q-panel {
                max-width: 45vw;
                padding: 6px 10px;
                top: 8px !important;
                left: 8px !important;
                border-radius: 12px;
            }

            #q-text {
                font-size: 10px;
                line-height: 1.3;
            }

            #hint-box {
                top: 10px !important;
                font-size: 9px;
            }

            #hint-box>div {
                padding: 4px 8px;
            }

            #score-panel {
                top: 8px !important;
                right: 8px !important;
            }

            #score-panel>div {
                padding: 6px 12px !important;
                border-width: 2px !important;
            }

            #score-display {
                font-size: 18px !important;
            }

            #overlay-emoji {
                font-size: 60px !important;
            }

            #overlay-msg {
                font-size: 32px !important;
            }

            #overlay-details {
                max-width: 90vw;
                padding: 12px;
            }
        }

        /* Very small phones */
        @media (max-width: 360px) {
            #q-panel {
                max-width: 40vw;
                padding: 4px 6px;
            }

            #q-text {
                font-size: 9px;
            }

            .flag-pill img {
                width: 16px !important;
            }
        }
    </style>
</head>

<body class="bg-gray-100 overflow-hidden select-none m-0 p-0 font-['Inter']">



    <!-- Main Game Container -->
    <div id="game-container" class="relative w-full h-full bg-gradient-to-b from-[#1E88E5] to-[#1565C0]">

        <div id="background-decor" class="absolute inset-0 z-0 pointer-events-none overflow-hidden">
        </div>

        <canvas id="gameCanvas" class="absolute inset-0 z-10"></canvas>

        <div id="ui-layer" class="absolute inset-0 z-20 pointer-events-none">
            <div id="flags-container" class="absolute inset-0 w-full h-full transition-opacity duration-500"
                style="opacity: 0;">
            </div>

            <div id="selection-box" class="absolute z-50"></div>

            <div id="hint-box" class="absolute top-20 left-1/2 -translate-x-1/2 pointer-events-none">

            </div>
        </div>

        <div id="overlay-container" class="fixed inset-0 z-50 bg-[#1565C0]/90 flex items-center justify-center">
            <div class="text-center transform -translate-y-12">
                <div id="overlay-emoji" class="text-9xl mb-4">üëè</div>
                <div id="overlay-msg" class="text-6xl font-black text-white tracking-widest mb-8">CORRECT</div>

                <div id="overlay-details"
                    class="bg-gradient-to-b from-white/95 to-[#E3F2FD]/90 border-4 border-white/75 rounded-3xl p-6 shadow-2xl max-w-2xl mx-auto text-left hidden">
                    <div class="mb-4">
                        <div class="text-[#0D47A1] text-sm font-bold uppercase">Question</div>
                        <div id="overlay-q" class="text-[#072B4F] text-xl font-semibold mt-1"></div>
                    </div>
                    <div>
                        <div class="text-[#1B5E20] text-sm font-bold uppercase">Answer</div>
                        <div id="overlay-a" class="text-[#2E7D32] text-2xl font-black mt-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <div class="absolute top-4 left-4 max-w-xs p-4 rounded-2xl shadow-lg question-panel pointer-events-none transition-opacity duration-500"
        id="q-panel">
        <div id="q-text" class="text-[#072B4F] text-sm font-semibold leading-tight">Rotate wheel...</div>
        <div id="a-text" class="text-[#0D47A1] text-base font-bold mt-2 hidden"></div>
    </div>

    <div id="score-panel" class="absolute top-6 right-6 hidden pointer-events-none">
        <div
            class="bg-gradient-to-r from-[#FF6B6B] to-[#FF5252] border-4 border-[#8B0000] rounded-2xl shadow-xl px-6 py-3 text-center">
            <div class="text-[#FFF59D] text-xs font-black tracking-widest uppercase">Score</div>
            <div id="score-display" class="text-white text-3xl font-black">0/0</div>
        </div>
    </div>


    </div>
    </div> <!-- End Game Container -->

    <script>
        /* ===========================
           DATA & CONFIG
           =========================== */

        let CONFIG = null;

        const RING_TEETH = 24;
        const GEAR_TEETH = 16;
        const GEAR_STEP = 360 / GEAR_TEETH;
        const RING_STEP = 360 / RING_TEETH;

        // Manual Offsets (in degrees) to fine-tune positions
        // Approx 1 degree = ~4-5 pixels on screen depending on device
        const MANUAL_OUTER_OFFSET = -19.0;
        const MANUAL_INNER_OFFSET = 0;

        // Game State
        let state = {
            gearAngle: 0,
            ringAngle: 0,
            gearTick: 0,
            ringTick: 0,
            gearIndex: 0,
            ringIndex: 0,
            roundStarted: false,
            canSubmit: false,
            score: 0,
            attempts: 0,
            selectedInnerIdx: null,
            targetGearAngle: 0,
            targetRingAngle: 0,

            // Zoom / Focus State
            zoom: 1.5,        // Start zoomed in
            targetZoom: 1.5,
            ringOpacity: 0,   // Start hidden
            targetRingOpacity: 0,

            // Tutorial state
            tutorialShown: false,
            tutorialPhase: 1
        };

        // Double-tap detection
        let lastTapTime = 0;
        const DOUBLE_TAP_DELAY = 300; // ms

        // Mappings
        let countryToQ = {};
        let countryToA = {};
        let innerItems = [];
        let outerItems = [];

        /* ===========================
           FESTIVE PARTICLES
           =========================== */
        class Particle {
            constructor(emoji, w, h) {
                this.emoji = emoji;
                this.reset(w, h, true);
            }

            reset(w, h, randomY = false) {
                this.x = Math.random() * w;
                this.y = randomY ? Math.random() * h : -50;
                this.size = Math.random() * 20 + 20; // 20-40px
                this.speed = Math.random() * 2 + 1;
                this.rotation = Math.random() * 360;
                this.rotSpeed = (Math.random() - 0.5) * 4;
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = Math.random() * 0.1;
                this.opacity = Math.random() * 0.5 + 0.3;
            }

            update(h) {
                this.y += this.speed;
                this.rotation += this.rotSpeed;
                this.wobble += this.wobbleSpeed;
                this.x += Math.sin(this.wobble) * 1; // Gentle sway

                if (this.y > h + 50) {
                    this.reset(window.innerWidth, h);
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.globalAlpha = this.opacity;
                ctx.font = `${this.size}px serif`;
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }

        const FESTIVAL_CONFIG = [
            { name: 'Christmas', month: 11, day: 25, emojis: ['‚ùÑÔ∏è', 'üéÖ', 'ü¶å', 'üéÑ', 'üéÅ', '‚õÑ'] }, // Month is 0-indexed (11 = Dec)
            { name: 'New Year', month: 0, day: 1, emojis: ['üéâ', 'ü•Ç', 'üéÜ', 'üåü', '‚ùÑÔ∏è'] },
            { name: 'Republic Day', month: 0, day: 26, emojis: ['üáÆüá≥', 'üèµÔ∏è', 'ü™Å', 'üïäÔ∏è'] },
            { name: 'Holi', month: 2, day: 14, emojis: ['üî¥', 'üü°', 'üü¢', 'üî´', 'üíß', 'üü£'] }, // 2025 approx
            { name: 'Independence Day', month: 7, day: 15, emojis: ['üáÆüá≥', 'üéÜ', 'ü™Å', 'üêØ'] },
            { name: 'Gandhi Jayanti', month: 9, day: 2, emojis: ['üïäÔ∏è', 'üëì', 'üß∂'] },
            { name: 'Diwali', month: 9, day: 20, emojis: ['ü™î', '‚ú®', 'üß®', 'üéá', 'üç¨'] }, // 2025 approx
        ];

        function getFestivalTheme() {
            const today = new Date();
            // Test Date: Uncomment to test specific festivals
            today.setMonth(0); today.setDate(1); // FORCE NEW YEAR

            // Check each festival
            for (let f of FESTIVAL_CONFIG) {
                // Construct festival date for current year
                let fDate = new Date(today.getFullYear(), f.month, f.day);

                // Handle year wrap for Dec/Jan if needed (simple approximation here covers mostly same year)
                // For 'New Year' (Jan 1) checked in Dec, or 'Christmas' (Dec 25) checked in Jan?
                // Logic: 4 days before, 3 days after.
                // Range: [Target - 4 days, Target + 3 days]

                const startWindow = new Date(fDate);
                startWindow.setDate(fDate.getDate() - 4);

                const endWindow = new Date(fDate);
                endWindow.setDate(fDate.getDate() + 3);

                if (today >= startWindow && today <= endWindow) {
                    return f.emojis;
                }
            }
            return null; // No festival
        }

        let particles = [];
        let festivalEmojis = null;

        function initParticles() {
            festivalEmojis = getFestivalTheme();
            if (!festivalEmojis) {
                // Default subtle floaters if no festival? Or just nothing?
                // User said "add fun elements... if diwali then... else..."
                // Maybe standard "sparkles" or "stars" if nothing else?
                // Let's stick to festival only for now as requested.
                // Or maybe a very light "star" field for generic days?
                // festivalEmojis = ['‚ú®', '‚≠ê', 'üîπ']; 
                return;
            }

            const isMobile = window.innerWidth < 500;
            const count = isMobile ? 10 : 25; // Don't overwhelm
            for (let i = 0; i < count; i++) {
                const randomEmoji = festivalEmojis[Math.floor(Math.random() * festivalEmojis.length)];
                particles.push(new Particle(randomEmoji, window.innerWidth, window.innerHeight));
            }
        }

        /* ===========================
           CANVAS & RENDERING
           =========================== */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, minDim;
        let centerX, centerY;
        let scaleFactor = 1; // Not used but good to have

        // Geometry Cache
        let geom = {
            ringOuterR: 0, ringRootR: 0, ringTipR: 0,
            gearRootR: 0, gearTipR: 0,
            gearCenter: { x: 0, y: 0 },
            ringCenter: { x: 0, y: 0 }
        };

        // Off-screen Caches
        let cachedGearCanvas = document.createElement('canvas');
        let cachedGearCtx = cachedGearCanvas.getContext('2d');
        let cachedRingCanvas = document.createElement('canvas');
        let cachedRingCtx = cachedRingCanvas.getContext('2d');

        function prerenderStaticAssets() {
            // 1. Prerender Ring
            // Size needs to cover the full ring diameter + margin
            const ringSize = geom.ringOuterR * 2 + 10;
            cachedRingCanvas.width = ringSize;
            cachedRingCanvas.height = ringSize;
            const rcx = ringSize / 2;
            const rcy = ringSize / 2;

            cachedRingCtx.clearRect(0, 0, ringSize, ringSize);
            cachedRingCtx.translate(rcx, rcy);

            // Ring Body
            cachedRingCtx.beginPath();
            cachedRingCtx.arc(0, 0, geom.ringOuterR, 0, Math.PI * 2);
            cachedRingCtx.arc(0, 0, geom.ringRootR, 0, Math.PI * 2, true);
            const grad = cachedRingCtx.createLinearGradient(-geom.ringOuterR, -geom.ringOuterR, geom.ringOuterR, geom.ringOuterR);
            grad.addColorStop(0, '#2E65B8');
            grad.addColorStop(0.5, '#8AC7FF');
            grad.addColorStop(1, '#1E56A8');
            cachedRingCtx.fillStyle = grad;
            cachedRingCtx.fill();

            // Internal Teeth (Ring)
            const ringStepRad = (2 * Math.PI) / RING_TEETH;
            cachedRingCtx.fillStyle = '#1565C0';
            for (let i = 0; i < RING_TEETH; i++) {
                const theta = i * ringStepRad; // No offset here, simply 0-aligned
                cachedRingCtx.save();
                cachedRingCtx.rotate(theta);
                drawInternalTooth(cachedRingCtx, 0, 0, geom.ringRootR, geom.ringTipR, RING_TEETH);
                cachedRingCtx.fillStyle = '#1565C0';
                cachedRingCtx.fill();
                cachedRingCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                cachedRingCtx.lineWidth = minDim * 0.002;
                cachedRingCtx.stroke();
                cachedRingCtx.restore();
            }

            // Bolts
            cachedRingCtx.fillStyle = '#B0C9DC';
            for (let i = 0; i < 12; i++) {
                const a = (i * 30) * (Math.PI / 180);
                const r = (geom.ringOuterR + geom.ringRootR) / 2;
                cachedRingCtx.beginPath();
                cachedRingCtx.arc(r * Math.cos(a), r * Math.sin(a), minDim * 0.005, 0, Math.PI * 2);
                cachedRingCtx.fill();
            }
            // End Ring Cache

            // 2. Prerender Gear
            const gearSize = geom.gearTipR * 2 + 10;
            cachedGearCanvas.width = gearSize;
            cachedGearCanvas.height = gearSize;
            const gcx = gearSize / 2;
            const gcy = gearSize / 2;

            cachedGearCtx.clearRect(0, 0, gearSize, gearSize);
            cachedGearCtx.translate(gcx, gcy);

            // Shadow
            cachedGearCtx.save();
            cachedGearCtx.translate(minDim * 0.005, minDim * 0.005);
            drawExternalGearPath(cachedGearCtx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            cachedGearCtx.fillStyle = 'rgba(0,0,0,0.3)';
            cachedGearCtx.fill();
            cachedGearCtx.restore();

            // Gear Body
            drawExternalGearPath(cachedGearCtx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            const gearGrad = cachedGearCtx.createRadialGradient(0, 0, geom.gearRootR * 0.5, 0, 0, geom.gearTipR);
            gearGrad.addColorStop(0, '#FFE082');
            gearGrad.addColorStop(1, '#FF8F00');
            cachedGearCtx.fillStyle = gearGrad;
            cachedGearCtx.fill();
            cachedGearCtx.strokeStyle = 'rgba(255,255,255,0.45)';
            cachedGearCtx.lineWidth = minDim * 0.003;
            cachedGearCtx.stroke();

            // Inner Hub Body (visual only, click is logically handled)
            const boreR = geom.gearRootR * 0.55;
            cachedGearCtx.beginPath();
            cachedGearCtx.arc(0, 0, boreR, 0, Math.PI * 2);
            // Default hub state (we'll draw dynamic text/highlight on top in main loop if needed, 
            // but for simple hub body we can cache the "normal" state. 
            // Actually, Hub changes color on zoom/tap? 
            // "Highlight hub when ready to click" -> Yes, gradient changes.
            // So rendering the STATIC part of the hub might be tricky if it animates color.
            // Let's CACHE everything EXCEPT the things that change every frame?
            // Or just cache the static "unhighlighted" hub and overdraw if highlighted?
            // The hub color change is subtle. Let's cache the standard Hub and just draw text on top.
            // Wait, the gradient changes based on `!state.roundStarted && state.zoom > 1.2`.
            // Let's CACHE the GEAR only, and draw HUB dynamically?
            // No, Gear body is heavy. Hub is simple circle.
            // Let's cache Gear Body. Draw Hub dynamically in render loop.
        }

        // Initialize state variables for animation
        state.offsetX = 0;
        state.targetOffsetX = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;



            minDim = Math.min(width, height);
            centerX = width / 2;
            centerY = height / 2;

            // Calculate Gear Geometry
            geom.ringOuterR = minDim * 0.48;
            const ringBandW = minDim * 0.07;
            geom.ringRootR = geom.ringOuterR - ringBandW;
            const toothH = minDim * 0.06;
            geom.ringTipR = geom.ringRootR - toothH - (minDim * 0.0075); // mesh tightness

            const ringPitchR = geom.ringRootR - toothH / 2;
            const gearPitchR = ringPitchR * (2 / 3); // 16/24 ratio

            geom.gearRootR = gearPitchR - toothH / 2;
            geom.gearTipR = gearPitchR + toothH / 2 + (minDim * 0.0075);

            // Initial Position update
            updateGearPositions();

            // RingCenter + RingPitchR = Contact
            // RingCenter = Contact - RingPitchR
            // RingCenter = GearCenter + GearPitchR - RingPitchR
            // RingCenter = GearCenter - (RingPitchR - GearPitchR)
            // RingCenter = GearCenter - centerOffset



            prerenderStaticAssets(); // Cache heavy paths

            render();
            updateDomElements(); // Update HTML overlay positions
        }

        window.addEventListener('resize', resize);

        // New function to update just position (for animation)
        function updateGearPositions() {
            // Recalculate center offset using radii from geometry
            const toothH = minDim * 0.06;
            const ringPitchR = geom.ringRootR - toothH / 2;
            const gearPitchR = ringPitchR * (2 / 3);
            const centerOffset = ringPitchR - gearPitchR;
            geom.centerOffset = centerOffset; // Store for animation targets
            const contactRad = 0;

            const cx = (width / 2) + (state.offsetX || 0);
            const cy = height / 2;

            // Center the INNER GEAR on the screen point (cx, cy)
            geom.gearCenter = { x: cx, y: cy };

            // The Outer Ring is offset to the LEFT to mesh at the RIGHT of the gear
            geom.ringCenter = {
                x: cx - centerOffset * Math.cos(contactRad),
                y: cy - centerOffset * Math.sin(contactRad)
            };
        }

        /* ===========================
           ANIMATION LOOP
           =========================== */
        function lerp(start, end, t) { return start * (1 - t) + end * t; }

        let lastTime = 0;
        function loop(timestamp) {
            try {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                // Spring/Lerp Physics
                state.gearAngle += (state.targetGearAngle - state.gearAngle) * 0.1;
                state.ringAngle += (state.targetRingAngle - state.ringAngle) * 0.1;

                // Zoom & Opacity Animation
                state.zoom += (state.targetZoom - state.zoom) * 0.05;
                state.ringOpacity += (state.targetRingOpacity - state.ringOpacity) * 0.05;

                // Position Animation
                if (Math.abs(state.targetOffsetX - state.offsetX) > 0.5) {
                    state.offsetX += (state.targetOffsetX - state.offsetX) * 0.05;
                    updateGearPositions(); // Update hitboxes as we move
                }

                // Update particles
                if (particles.length > 0) {
                    particles.forEach(p => p.update(height));
                }

                render();
                updateUiLogic();
                updateDomElements();

                requestAnimationFrame(loop);
            } catch (e) {
                console.error(e);
                const qText = document.getElementById('q-text');
                if (qText) qText.innerText = "ERROR: " + e.message;
            }
        }

        // ... (Draw functions)
        function polar(r, theta) {
            return { x: r * Math.cos(theta), y: r * Math.sin(theta) };
        }

        function drawExternalGearPath(ctx, cx, cy, rRoot, rTip, numTeeth) {
            const step = (Math.PI * 2) / numTeeth;
            const halfStep = step / 2;

            // Simplistic Involute approximation
            // Tooth thickness at pitch line ~ half pitch
            const toothWidthAng = halfStep * 0.5;

            ctx.beginPath();
            for (let i = 0; i < numTeeth; i++) {
                // Tooth-Centric: Shift by half step so Tooth is at 0 (not Root)
                const theta = i * step - halfStep;
                // Root
                ctx.arc(cx, cy, rRoot, theta - halfStep / 2 + 0.05, theta + halfStep / 2 - 0.05);

                // Tooth Up
                const p1 = polar(rRoot, theta + halfStep / 2 - 0.05);
                const p2 = polar(rTip, theta + halfStep / 2 + 0.05);
                const p3 = polar(rTip, theta + step - halfStep / 2 - 0.05);
                const p4 = polar(rRoot, theta + step - halfStep / 2 + 0.05);

                ctx.lineTo(p2.x, p2.y);
                ctx.arc(cx, cy, rTip, theta + halfStep / 2 + 0.05, theta + step - halfStep / 2 - 0.05);
                ctx.lineTo(p4.x, p4.y);
            }
            ctx.closePath();
        }

        function drawInternalTooth(ctx, cx, cy, rRoot, rTip, numTeeth) {
            // For internal gear (ring), teeth point INWARDS - THICK GEAR TEETH
            // Matching Kotlin's buildSingleInternalTooth with rounded corners

            const toothH = rRoot - rTip;
            const pitch = (2 * Math.PI) / numTeeth;
            const topFrac = 0.42; // tooth top width fraction
            const top = pitch * topFrac;
            const flank = (pitch - top) / 2;

            // Tooth dimensions - THICKER teeth
            const baseWidth = minDim * 0.035;  // Wide base
            const tipWidth = minDim * 0.018;   // Narrower tip

            // Rounded fillet radii
            const rootFillet = toothH * 0.15;
            const tipRound = toothH * 0.12;

            ctx.beginPath();
            // Start at bottom-left of tooth base
            ctx.moveTo(rRoot, -baseWidth);

            // Left flank with curve to tip
            ctx.quadraticCurveTo(
                rRoot - toothH * 0.3, -baseWidth * 0.7,
                rTip + tipRound, -tipWidth
            );

            // Tip (rounded)
            ctx.lineTo(rTip + tipRound, tipWidth);

            // Right flank with curve to base
            ctx.quadraticCurveTo(
                rRoot - toothH * 0.3, baseWidth * 0.7,
                rRoot, baseWidth
            );

            ctx.closePath();
        }

        function render() {
            if (!CONFIG) return;

            ctx.clearRect(0, 0, width, height);

            ctx.save();
            ctx.save();
            ctx.translate(centerX + state.offsetX, centerY);
            ctx.scale(state.zoom, state.zoom);
            ctx.translate(-centerX - state.offsetX, -centerY);

            // 0. Draw Background Particles (Behind everything)
            if (particles.length > 0) {
                particles.forEach(p => p.draw(ctx));
            }

            // 1. Draw Outer Ring (Fade in)
            if (state.ringOpacity > 0.01) {
                ctx.globalAlpha = state.ringOpacity;

                ctx.save();
                // Draw Ring at its calculated center (offset from gear)
                ctx.translate(geom.ringCenter.x, geom.ringCenter.y);

                // Rotated Draw from Cache
                // The cache is 0-aligned. We simply rotate the context by the Ring Angle + Offset.
                const rotOffset = (state.ringAngle + RING_STEP / 2) * (Math.PI / 180);
                ctx.rotate(rotOffset);

                // Draw Image centered
                const halfSize = cachedRingCanvas.width / 2;
                ctx.drawImage(cachedRingCanvas, -halfSize, -halfSize);

                ctx.restore();
                ctx.globalAlpha = 1.0;
            }

            // 2. Draw Inner Gear
            // Gear Center
            ctx.save();
            ctx.translate(geom.gearCenter.x, geom.gearCenter.y);
            // Apply rotation ONCE for the whole group (Body + Hub + Text)
            ctx.rotate(state.gearAngle * (Math.PI / 180));

            // Draw Cached Gear Body
            const gHalf = cachedGearCanvas.width / 2;
            ctx.drawImage(cachedGearCanvas, -gHalf, -gHalf);

            // Inner Hub (Dynamic because it changes color/state)
            const boreR = geom.gearRootR * 0.55;
            ctx.beginPath();
            ctx.arc(0, 0, boreR, 0, Math.PI * 2);
            const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, boreR);
            // Highlight hub when ready to click?
            if (!state.roundStarted && state.zoom > 1.2) {
                hubGrad.addColorStop(0, '#B0BEC5'); // Lighter
                hubGrad.addColorStop(1, '#546E7A');
            } else {
                hubGrad.addColorStop(0, '#95A5AE');
                hubGrad.addColorStop(1, '#3A454B');
            }
            ctx.fillStyle = hubGrad;
            ctx.fill();

            // Hub Text "TAP" if zoomed
            const hubIsMobile = minDim < 500;
            if (!state.roundStarted && state.zoom > 1.2) {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.035 : 0.04)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("TAP", 0, -minDim * 0.01);
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.016 : 0.02)}px Inter`;
                ctx.fillText("TO SELECT", 0, minDim * 0.025);
            } else if (state.roundStarted) {
                // Show tap instructions when outer wheel is visible
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.018 : 0.022)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("1√ó CHECK", 0, -minDim * 0.018);
                ctx.font = `bold ${minDim * (hubIsMobile ? 0.015 : 0.018)}px Inter`;
                ctx.fillStyle = 'rgba(255,200,200,0.9)';
                ctx.fillText("2√ó HOME", 0, minDim * 0.015);
            } else {
                // Bolts normally
                ctx.fillStyle = '#263238';
                for (let k = 0; k < 6; k++) {
                    const a = (k * 60) * (Math.PI / 180);
                    const bx = boreR * 0.7 * Math.cos(a);
                    const by = boreR * 0.7 * Math.sin(a);
                    ctx.beginPath();
                    ctx.arc(bx, by, minDim * 0.006, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 3. Draw Inner Text
            // Parent context is ALREADY rotated by gearAngle!
            // We just need to make sure text is drawing relative to that.

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Mobile-optimized font size - scales down on smaller screens
            const isMobile = minDim < 500;
            const baseFontSize = isMobile ? Math.max(7, minDim * 0.015) : Math.max(10, minDim * 0.018);
            const textR = geom.gearRootR * (isMobile ? 0.78 : 0.82);
            /* const gearStepRad = (2 * Math.PI) / GEAR_TEETH; */ // Already defined? No, it's local in render.
            // Wait, gearStepRad is defined in render, need to ensure it's there.
            const gearStepRad = (2 * Math.PI) / GEAR_TEETH;

            innerItems.forEach((label, i) => {
                // Hide non-selected items when round is active (outer ring visible)
                let itemAlpha = 1.0;
                if (state.roundStarted && state.selectedInnerIdx !== null && state.selectedInnerIdx !== i) {
                    itemAlpha = Math.max(0, 1 - state.ringOpacity * 2);
                }
                if (itemAlpha < 0.01) return;

                const theta = i * gearStepRad + (MANUAL_INNER_OFFSET * Math.PI / 180);
                const x = textR * Math.cos(theta);
                const y = textR * Math.sin(theta);

                ctx.font = `bold ${baseFontSize}px Inter`;

                ctx.save();
                ctx.globalAlpha = itemAlpha;
                ctx.translate(x, y);
                ctx.rotate(theta);

                const globalDeg = (state.gearAngle + (i * 360 / GEAR_TEETH) + (gearStepRad * 180 / Math.PI / 2)) % 360;
                let normDeg = globalDeg < 0 ? globalDeg + 360 : globalDeg;

                // Flip logic for readability
                if (normDeg > 90 && normDeg < 270) {
                    ctx.rotate(Math.PI);
                }

                ctx.fillStyle = '#003366';
                ctx.fillText(label, 0, 0);
                ctx.restore();
            });

            ctx.restore(); // End Gear

            ctx.restore(); // End Zoom Scale
        }

        // ... updateDomElements (Uses state.zoom to scale positions?)
        // Actually, CSS transform for HTML elements (Pills) needs to handle zoom?
        // Or we just zoom the canvas and keep HTML elements on top?
        // If we zoom canvas, the coordinate system changes.
        // We probably need to apply zoom to DOM element positions too.

        function updateDomElements() {
            if (!minDim) return;

            // Update flags container opacity to match ring opacity
            const flagsContainer = document.getElementById('flags-container');
            if (flagsContainer) {
                flagsContainer.style.opacity = state.ringOpacity;
            }

            // Background Stickers (Parallax or static? Static for now)
            // ...

            // Flag Pills - need to match zoomed coordinate system?
            // If canvas is scaled via ctx.scale, visual is zoomed.
            // HTML elements are independent.
            // We must project the zoomed coordinates to screen coordinates.

            // Scale center: centerX, centerY
            // ScreenX = centerX + (WorldX - centerX) * zoom
            // ScreenY = centerY + (WorldY - centerY) * zoom

            // Position flags on the outer ring band (middle of the ring)
            const radius = (geom.ringOuterR + geom.ringRootR) / 2;
            const ringPitch = (2 * Math.PI) / RING_TEETH;
            // Shift by half step to be in the "dip"
            const phaseOffset = (state.ringAngle + RING_STEP / 2 + 4 + RING_STEP / 2 + (RING_STEP / 2) + (RING_STEP / 2) + MANUAL_OUTER_OFFSET) * (Math.PI / 180);

            // Find the 5 rightmost indices (closest to 0 degrees / right side)
            function getRightmost5Indices() {
                const indices = [];
                for (let i = 0; i < RING_TEETH; i++) {
                    const theta = i * ringPitch + phaseOffset;
                    const angleDeg = (theta * 180 / Math.PI) % 360;
                    // Normalize to -180 to 180
                    let normAngle = angleDeg;
                    if (normAngle > 180) normAngle -= 360;
                    indices.push({ idx: i, angle: Math.abs(normAngle) });
                }
                // Sort by closest to 0 (right side)
                indices.sort((a, b) => a.angle - b.angle);
                return new Set(indices.slice(0, 5).map(x => x.idx));
            }

            const rightmost5 = getRightmost5Indices();

            flagElements.forEach((el, i) => {
                if (state.ringOpacity < 0.1) {
                    el.style.opacity = '0';
                    return;
                }
                el.style.opacity = state.ringOpacity;

                const theta = i * ringPitch + phaseOffset;
                // World Coords
                const wx = geom.ringCenter.x + radius * Math.cos(theta);
                const wy = geom.ringCenter.y + radius * Math.sin(theta);

                // Screen Coords - Origin is centerX + offsetX
                const ox = centerX + (state.offsetX || 0);
                const oy = centerY;

                const sx = ox + (wx - ox) * state.zoom;
                const sy = oy + (wy - oy) * state.zoom;

                el.style.left = sx + 'px';
                el.style.top = sy + 'px';

                // Dynamic sizing - rightmost 5 get progressively bigger based on rank
                const isBig = rightmost5.has(i);
                const baseScale = state.zoom;

                // Get rank (0 = closest to right, 4 = 5th closest)
                let rank = -1;
                if (isBig) {
                    const indices = [];
                    for (let j = 0; j < RING_TEETH; j++) {
                        const t = j * ringPitch + phaseOffset;
                        const aDeg = (t * 180 / Math.PI) % 360;
                        let na = aDeg;
                        if (na > 180) na -= 360;
                        indices.push({ idx: j, angle: Math.abs(na) });
                    }
                    indices.sort((a, b) => a.angle - b.angle);
                    rank = indices.findIndex(x => x.idx === i);
                }

                // Scale: rank 0 = 1.5x, rank 1 = 1.4x, rank 2 = 1.3x, rank 3 = 1.2x, rank 4 = 1.1x
                // Reduced for mobile
                const flagIsMobile = minDim < 500;
                let sizeScale = 1.0;
                if (rank >= 0 && rank < 5) {
                    const maxFlagScale = flagIsMobile ? 1.25 : 1.5;
                    const flagScaleStep = flagIsMobile ? 0.05 : 0.1;
                    sizeScale = maxFlagScale - (rank * flagScaleStep);
                }

                el.style.transform = `translate(-50%, -50%) scale(${baseScale * sizeScale})`;

                // Visual enhancements for bigger flags
                if (rank >= 0 && rank < 3) {
                    el.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 255, 255, 0.2)';
                    el.style.borderWidth = flagIsMobile ? '2px' : '4px';
                } else {
                    el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.2)';
                    el.style.borderWidth = flagIsMobile ? '2px' : '3px';
                }

                // Also adjust the image/content size for the big ones
                const img = el.querySelector('img');
                if (img) {
                    // Gradient image sizes based on rank - smaller for mobile
                    const baseSizes = flagIsMobile ? [28, 25, 23, 21, 19, 18] : [52, 46, 42, 38, 35, 32];
                    const sizeIdx = rank >= 0 && rank < 5 ? rank : 5;
                    img.style.width = baseSizes[sizeIdx] + 'px';
                }
            });
        }

        /* ===========================
           LOGIC updates
           =========================== */
        function updateUiLogic() {
            // Active Item at 0 degrees (Right)
            const contactDeg = 0;
            const gearPitch = 360 / GEAR_TEETH;

            let normGear = state.gearAngle % 360;
            if (normGear < 0) normGear += 360;

            // at 0 deg: angle + i*pitch = 0  => i*pitch = -angle
            // Invert logic:
            // The item at 0 degrees is the one where (i * step + currentAngle) % 360 ~= 0
            // i * step = -currentAngle
            // i = -currentAngle / step

            const rawIdx = (contactDeg - state.gearAngle) / gearPitch;
            let idx = Math.round(rawIdx) % GEAR_TEETH;
            if (idx < 0) idx += GEAR_TEETH;

            const activeItem = innerItems[idx];

            if (!state.roundStarted) {
                // Updating UI
                document.getElementById('q-text').innerText = countryToQ[activeItem] || activeItem;
                state.activeInnerLabel = activeItem;
                state.activeInnerIdx = idx;

                // Selection Box Logic
                // It should be at geom.gearCenter.x + geom.gearRootR, geom.gearCenter.y
                // Scaled by Zoom!

                const box = document.getElementById('selection-box');
                const dist = Math.abs(rawIdx - Math.round(rawIdx));

                if (dist < 0.1) {
                    // Coordinates in World Space
                    const wx = geom.gearCenter.x + geom.gearRootR; // Right edge
                    const wy = geom.gearCenter.y;

                    // To Screen Space - Origin is centerX + offsetX
                    const ox = centerX + (state.offsetX || 0);
                    const oy = centerY;

                    const sx = ox + (wx - ox) * state.zoom;
                    const sy = oy + (wy - oy) * state.zoom;

                    box.style.display = 'block';

                    // Dynamic Size based on screen & zoom
                    const boxW = minDim * 0.35 * state.zoom;
                    const boxH = minDim * 0.09 * state.zoom;

                    box.style.width = boxW + 'px';
                    box.style.height = boxH + 'px';

                    const textR = geom.gearRootR * 0.88;
                    const tx = geom.gearCenter.x + textR;
                    const screenTx = ox + (tx - ox) * state.zoom;

                    // Center box on the text position
                    box.style.left = (screenTx - (boxW / 2)) + 'px';
                    box.style.top = (sy - (boxH / 2)) + 'px';

                } else {
                    box.style.display = 'none';
                }
            } else {
                document.getElementById('selection-box').style.display = 'none';
            }
        }

        /* ===========================
           TUTORIAL ANIMATIONS
           =========================== */




        function handleClick(x, y) {
            // Check Hub Click first
            const dx = x - geom.gearCenter.x;
            const dy = y - geom.gearCenter.y;
            const dist = Math.hypot(dx, dy);

            if (dist < geom.gearRootR * 0.55) {
                // Hub Clicked! - Check for double tap
                const now = Date.now();
                const isDoubleTap = (now - lastTapTime) < DOUBLE_TAP_DELAY;
                lastTapTime = now;

                if (!state.roundStarted) {
                    // Phase 1: Single tap to start round
                    // CONFIRM SELECTION -> Start Zoom Out
                    state.roundStarted = true;
                    state.targetZoom = 1.0;          // Zoom Out
                    state.targetRingOpacity = 1.0;   // Fade In Outer
                    state.targetOffsetX = geom.centerOffset; // Shift so Ring is Centered

                    document.getElementById('hint-box').style.opacity = '0';
                    document.getElementById('score-panel').classList.remove('hidden');
                    updateScore();

                    // Recalculate match?
                    state.selectedInnerIdx = state.activeInnerIdx;
                } else {
                    // Round already started - check tap type
                    if (isDoubleTap) {
                        // DOUBLE TAP = RESET (W key - go home)
                        state.roundStarted = false;
                        state.targetZoom = 1.5;
                        state.targetRingOpacity = 0;
                        state.targetOffsetX = 0;         // Shift Back Center
                        state.score = 0;
                        state.attempts = 0;
                        state.selectedInnerIdx = null;
                        updateScore();
                        document.getElementById('hint-box').style.opacity = '1';
                        document.getElementById('score-panel').classList.add('hidden');
                    } else {
                        // SINGLE TAP = CHECK ANSWER (S key - confirm)
                        checkAnswer();
                    }
                }
                return;
            }

            if (state.roundStarted) return;

            // Text Click Logic (Drag-to-rotate)
            // ... (Existing click logic, updated for 0 deg?)

            const clickAngle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Normalize everything
            let normalizedGearAngle = state.gearAngle % 360;
            if (normalizedGearAngle < 0) normalizedGearAngle += 360;

            let normalizedClick = clickAngle;
            if (normalizedClick < 0) normalizedClick += 360;

            const step = 360 / GEAR_TEETH;
            let targetI = (normalizedClick - normalizedGearAngle - (step / 2)) / step;
            let i = Math.round(targetI);
            i = ((i % GEAR_TEETH) + GEAR_TEETH) % GEAR_TEETH;

            if (i >= 0 && i < GEAR_TEETH) {
                rotateToIndex(i);
            }
        }

        function rotateToIndex(idx) {
            // Target: We want item 'idx' to be at 0 DEGREES (Right)
            // i * step + TargetGearAngle = 0
            // TargetGearAngle = -i * step

            const step = 360 / GEAR_TEETH;
            let targetG = -idx * step;

            let current = state.gearAngle;
            let diff = targetG - current;
            diff = diff % 360;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;

            state.targetGearAngle = current + diff;
            state.targetRingAngle = state.ringAngle + diff * (2 / 3);
        }

        function snapToGrid() {
            // Optional: Snap to nearest gear tooth alignment
            // Not strictly required but feels nicer.
            const step = 360 / GEAR_TEETH;
            const current = state.gearAngle;
            const remainder = current % step;
            // Snap logic... maybe later if user asks.
        }

        function updateScore() {
            document.getElementById('score-display').innerText = `${state.score}/${state.attempts}`;
        }

        // Get the flag at the active position (rightmost on outer ring)
        function getActiveOuterFlag() {
            const ringPitch = (2 * Math.PI) / RING_TEETH;
            // Shift by half step to be in the "dip"
            const phaseOffset = (state.ringAngle + RING_STEP / 2 + 4 + RING_STEP / 2 + (RING_STEP / 2) + (RING_STEP / 2) + MANUAL_OUTER_OFFSET) * (Math.PI / 180);

            // Find which flag is closest to 0 degrees (right side)
            let closestIdx = 0;
            let closestAngle = Infinity;

            for (let i = 0; i < RING_TEETH; i++) {
                const theta = i * ringPitch + phaseOffset;
                let angleDeg = (theta * 180 / Math.PI) % 360;
                if (angleDeg > 180) angleDeg -= 360;
                if (angleDeg < -180) angleDeg += 360;

                if (Math.abs(angleDeg) < closestAngle) {
                    closestAngle = Math.abs(angleDeg);
                    closestIdx = i;
                }
            }

            return outerItems[closestIdx] || '';
        }

        // Show overlay slide animation (like Kotlin's OverlaySlide)
        function showOverlay(isCorrect, question, answer) {
            const overlay = document.getElementById('overlay-container');
            const emoji = document.getElementById('overlay-emoji');
            const msg = document.getElementById('overlay-msg');
            const details = document.getElementById('overlay-details');
            const qText = document.getElementById('overlay-q');
            const aText = document.getElementById('overlay-a');

            // Set content
            emoji.innerText = isCorrect ? 'üëè' : 'üò•';
            msg.innerText = isCorrect ? 'CORRECT' : 'TRY AGAIN';
            msg.style.color = isCorrect ? '#4CAF50' : '#FF5252';

            if (question || answer) {
                details.classList.remove('hidden');
                qText.innerText = question || '';

                // Show Answer + Flag Image if available
                const code = typeof flagEmojiToCountryCode === 'function' ? flagEmojiToCountryCode(answer) : null;
                if (code) {
                    aText.innerHTML = `<span class="mr-2">${answer}</span><img src="https://flagcdn.com/w80/${code}.png" style="height: 1.2em; vertical-align: middle; border-radius: 4px; display: inline-block;">`;
                } else {
                    aText.innerText = answer || '';
                }

                aText.style.color = isCorrect ? '#2E7D32' : '#B71C1C';
            } else {
                details.classList.add('hidden');
            }

            // Slide in
            overlay.classList.add('slide-in');

            // Slide out after delay
            setTimeout(() => {
                overlay.classList.remove('slide-in');
            }, 1500);
        }

        // Check answer and show result
        function checkAnswer() {
            if (!state.roundStarted) return;

            const innerLabel = state.activeInnerLabel;
            const expectedFlag = countryToA[innerLabel];
            const selectedFlag = getActiveOuterFlag();

            const isCorrect = expectedFlag === selectedFlag;

            state.attempts++;
            if (isCorrect) state.score++;
            updateScore();

            const question = countryToQ[innerLabel] || innerLabel;
            const answer = expectedFlag || selectedFlag;

            showOverlay(isCorrect, question, answer);
        }

        let flagElements = [];

        // Convert flag emoji to country code (e.g., "üáÆüá≥" -> "in")
        function flagEmojiToCountryCode(flag) {
            if (!flag || flag.length < 2) return null;
            const codePoints = [...flag].map(c => c.codePointAt(0));
            // Regional indicator symbols are in range 0x1F1E6-0x1F1FF (A-Z)
            const letters = codePoints
                .filter(cp => cp >= 0x1F1E6 && cp <= 0x1F1FF)
                .map(cp => String.fromCharCode(cp - 0x1F1E6 + 65));
            if (letters.length === 2) {
                return letters.join('').toLowerCase();
            }
            return null;
        }

        function createFlagPills() {
            const container = document.getElementById('flags-container');
            container.innerHTML = '';
            flagElements = [];

            outerItems.forEach((flag, i) => {
                const el = document.createElement('div');
                el.className = 'flag-pill';

                // Try to convert emoji to country code and use flag image
                const countryCode = flagEmojiToCountryCode(flag);
                if (countryCode) {
                    el.innerHTML = `<img src="https://flagcdn.com/w40/${countryCode}.png" alt="${flag}" style="width: 32px; height: auto; border-radius: 3px;">`;
                } else {
                    // Fallback to emoji if conversion fails
                    el.innerHTML = `<span class="flag-emoji">${flag}</span>`;
                }

                container.appendChild(el);
                flagElements.push(el);
            });
        }

        function initInteraction() {
            let isDragging = false;
            let lastX = 0, lastY = 0;

            const handleStart = (x, y) => {
                // Allow dragging from anywhere on screen
                isDragging = true;
                lastX = x;
                lastY = y;

                // Calculate click position for hub check
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;

                // Still handle hub clicks for selection
                if (Math.hypot(dx, dy) < geom.gearRootR * 0.55) {
                    handleClick(x, y);
                }
            };

            const handleMove = (x, y) => {
                if (!isDragging) return;
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;
                const angle = Math.atan2(dy, dx);

                const prevA = Math.atan2(lastY - geom.gearCenter.y, lastX - geom.gearCenter.x);
                let delta = angle - prevA;

                if (delta > Math.PI) delta -= Math.PI * 2;
                if (delta < -Math.PI) delta += Math.PI * 2;

                // Apply rotation
                state.targetGearAngle += delta * (180 / Math.PI);
                state.targetRingAngle += delta * (180 / Math.PI) * (2 / 3);

                lastX = x;
                lastY = y;
            };

            const handleEnd = () => {
                isDragging = false;

                // Snap to nearest tooth
                const step = 360 / GEAR_TEETH;
                const current = state.targetGearAngle;
                const snapped = Math.round(current / step) * step;

                const diff = snapped - current;
                state.targetGearAngle = snapped;
                state.targetRingAngle += diff * (2 / 3);
            };

            canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', e => {
                // Prevent emulated mouse events (fixes double-tap issue)
                e.preventDefault();
                if (e.touches.length > 1) return;
                const t = e.touches[0];
                handleStart(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchmove', e => {
                if (!isDragging) return;
                e.preventDefault();
                const t = e.touches[0];
                handleMove(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchend', handleEnd);

            // Key Controls
            window.addEventListener('keydown', e => {
                const step = 360 / GEAR_TEETH;
                if (e.key === 'ArrowRight' || e.key === 'd') {
                    state.targetGearAngle -= step;
                    state.targetRingAngle -= step * 0.666;
                }
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    state.targetGearAngle += step;
                    state.targetRingAngle += step * 0.666;
                }
                if (e.key === 's' || e.key === ' ') {
                    if (!state.roundStarted) {
                        // Start round - simulate hub click
                        handleClick(geom.gearCenter.x, geom.gearCenter.y);
                    } else {
                        // Check answer
                        checkAnswer();
                    }
                }
                if (e.key === 'w') {
                    // Reset to initial state
                    state.roundStarted = false;
                    state.targetZoom = 1.5;
                    state.targetRingOpacity = 0;
                    state.targetOffsetX = 0;         // Shift Back Center
                    state.score = 0;
                    state.attempts = 0;
                    state.selectedInnerIdx = null;
                    updateScore();
                    document.getElementById('hint-box').style.opacity = '1';
                    document.getElementById('score-panel').classList.add('hidden');
                }
            });
        }

        // Init
        async function initGame() {
            initInteraction(); // Enable controls
            createBackgroundStickers(); // Add emoji decorations like Kotlin
            initParticles(); // FESTIVE PARTICLES
            try {
                const response = await fetch('flags.json');
                CONFIG = await response.json();

                // Initialize Mappings
                countryToQ = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.question]));
                countryToA = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.answer]));
                innerItems = CONFIG.innerOrder;

                // Pad outer flags
                outerItems = [...CONFIG.outerFlags];
                while (outerItems.length < RING_TEETH) outerItems.push("");
                outerItems = outerItems.slice(0, RING_TEETH);

                // Initialize DOM pills
                createFlagPills();

                // Start
                resize();
                requestAnimationFrame(loop);

                // Show tutorial after a brief delay
                setTimeout(() => {
                    showInitialTutorial();
                }, 1000);
            } catch (error) {
                console.error("Failed to load game configuration:", error);
                document.getElementById('q-text').innerText = "Error loading game data.";
            }
        }

        // Background decorations like Kotlin's BackgroundDecorStatic
        function createBackgroundStickers() {
            const container = document.getElementById('background-decor');
            if (!container) return;

            const stickers = [
                { emoji: 'üìö', angle: 350, radius: 0.57, size: 70, c1: '#7B61FF', c2: '#4D8AFF', rot: -6 },
                { emoji: '‚úèÔ∏è', angle: 20, radius: 0.55, size: 60, c1: '#FFA24C', c2: '#FFC35B', rot: 8 },
                { emoji: 'üß™', angle: 65, radius: 0.58, size: 65, c1: '#33D1B1', c2: '#1CB5E0', rot: -4 },
                { emoji: 'ü™™', angle: 110, radius: 0.56, size: 66, c1: '#58C9F3', c2: '#2D9CDB', rot: 5 },
                { emoji: 'üåé', angle: 155, radius: 0.60, size: 75, c1: '#6EE7F9', c2: '#22D3EE', rot: 0 }
            ];

            stickers.forEach(s => {
                const el = document.createElement('div');
                el.style.cssText = `
                    position: absolute;
                    width: ${s.size}px;
                    height: ${s.size}px;
                    background: linear-gradient(135deg, ${s.c1}, ${s.c2});
                    border-radius: 16px;
                    border: 3px solid rgba(255, 255, 255, 0.55);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: ${s.size * 0.45}px;
                    transform: rotate(${s.rot}deg);
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.1);
                    pointer-events: none;
                `;
                el.innerText = s.emoji;
                el.dataset.angle = s.angle;
                el.dataset.radius = s.radius;
                container.appendChild(el);
            });

            // Position stickers on resize
            function positionStickers() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const minD = Math.min(w, h);
                const cx = w / 2;
                const cy = h / 2;

                container.querySelectorAll('div').forEach(el => {
                    const angle = parseFloat(el.dataset.angle) * (Math.PI / 180);
                    const radius = parseFloat(el.dataset.radius) * minD;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    el.style.left = (x - el.offsetWidth / 2) + 'px';
                    el.style.top = (y - el.offsetHeight / 2) + 'px';
                });
            }

            positionStickers();
            window.addEventListener('resize', positionStickers);
        }

        initGame();
    </script>
</body>

</html>
