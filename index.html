<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Wheel Gear Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #1E88E5, #1565C0);
            font-family: 'Inter', sans-serif;
            user-select: none;
            /* Prevent text selection */
        }

        /* Utility for centering absolute items */
        .center-abs {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 3D Sticker Effect Class */
        .sticker-3d {
            box-shadow:
                0px 10px 20px rgba(0, 0, 0, 0.15),
                inset 0px -4px 0px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        /* Flag Pill Styles */
        .flag-pill {
            position: absolute;
            background: linear-gradient(to bottom, #FFFFFF, #F6FAFF);
            border: 3px solid rgba(13, 71, 161, 0.85);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            white-space: nowrap;
            pointer-events: none;
            transform-origin: center center;
            z-index: 20;
        }

        .flag-text {
            color: #0B2A6E;
            font-weight: 700;
            font-size: 13px;
        }

        .flag-emoji {
            font-size: 24px;
        }

        /* Question Panel */
        .question-panel {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.5));
            border: 3px solid #64B5F6;
            backdrop-filter: blur(4px);
        }

        /* Selection Box Animation */
        #selection-box {
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none;
            /* Hidden by default */
        }

        /* Overlay Slide Animation */
        #overlay-container {
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateY(-100%);
        }

        .slide-in {
            transform: translateY(0%) !important;
        }

        /* Landscape Enforcement */
        #rotate-message {
            display: none;
        }

        @media only screen and (orientation: portrait) and (max-width: 1024px) {
            #game-container {
                display: none !important;
            }

            #rotate-message {
                display: flex !important;
            }
        }
    </style>
</head>

<body class="bg-gray-100 overflow-hidden select-none m-0 p-0 font-['Inter']">

    <!-- Landscape Warning Overlay -->
    <div id="rotate-message"
        class="fixed inset-0 z-[99999] bg-[#1565C0] flex flex-col items-center justify-center text-white">
        <div class="text-6xl mb-6 animate-bounce">üì±üîÑ</div>
        <div class="text-3xl font-black text-center px-8">PLEASE ROTATE DEVICE</div>
        <p class="mt-4 text-white/80">This game works best in Landscape Mode</p>
    </div>

    <!-- Main Game Container -->
    <div id="game-container" class="relative w-full h-full bg-gradient-to-b from-[#1E88E5] to-[#1565C0]">

        <div id="background-decor" class="absolute inset-0 z-0 pointer-events-none overflow-hidden">
        </div>

        <canvas id="gameCanvas" class="absolute inset-0 z-10"></canvas>

        <div id="ui-layer" class="absolute inset-0 z-20 pointer-events-none overflow-hidden">
            <div id="flags-container" class="absolute inset-0 w-full h-full opacity-0 transition-opacity duration-500">
            </div>

            <div id="selection-box" class="absolute z-50"></div>

            <div id="hint-box" class="absolute top-20 left-1/2 -translate-x-1/2 pointer-events-auto">
                <div
                    class="bg-gradient-to-r from-[#1976D2] to-[#64B5F6] border-2 border-white/70 rounded-2xl shadow-lg px-5 py-2">
                    <p class="text-white text-sm font-bold whitespace-nowrap">Rotate wheel (A/D) ‚Ä¢ Select (S) ‚Ä¢ Reset
                        (W)
                    </p>
                </div>
            </div>
        </div>

        <div id="overlay-container" class="fixed inset-0 z-50 bg-[#1565C0]/90 flex items-center justify-center">
            <div class="text-center transform -translate-y-12">
                <div id="overlay-emoji" class="text-9xl mb-4">üëè</div>
                <div id="overlay-msg" class="text-6xl font-black text-white tracking-widest mb-8">CORRECT</div>

                <div id="overlay-details"
                    class="bg-gradient-to-b from-white/95 to-[#E3F2FD]/90 border-4 border-white/75 rounded-3xl p-6 shadow-2xl max-w-2xl mx-auto text-left hidden">
                    <div class="mb-4">
                        <div class="text-[#0D47A1] text-sm font-bold uppercase">Question</div>
                        <div id="overlay-q" class="text-[#072B4F] text-xl font-semibold mt-1"></div>
                    </div>
                    <div>
                        <div class="text-[#1B5E20] text-sm font-bold uppercase">Answer</div>
                        <div id="overlay-a" class="text-[#2E7D32] text-2xl font-black mt-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="absolute top-4 left-4 max-w-xs p-4 rounded-2xl shadow-lg question-panel pointer-events-auto transition-opacity duration-500"
        id="q-panel">
        <div id="q-text" class="text-[#072B4F] text-sm font-semibold leading-tight">Rotate wheel...</div>
        <div id="a-text" class="text-[#0D47A1] text-base font-bold mt-2 hidden"></div>
    </div>

    <div id="score-panel" class="absolute top-6 right-6 hidden pointer-events-auto">
        <div
            class="bg-gradient-to-r from-[#FF6B6B] to-[#FF5252] border-4 border-[#8B0000] rounded-2xl shadow-xl px-6 py-3 text-center">
            <div class="text-[#FFF59D] text-xs font-black tracking-widest uppercase">Score</div>
            <div id="score-display" class="text-white text-3xl font-black">0/0</div>
        </div>
    </div>

    <div id="hint-box" class="absolute top-20 left-1/2 -translate-x-1/2 pointer-events-auto">
        <div
            class="bg-gradient-to-r from-[#1976D2] to-[#64B5F6] border-2 border-white/70 rounded-2xl shadow-lg px-5 py-2">
            <div class="text-white text-sm font-bold shadow-sm">Rotate to pick Question, Click Question or Press 'S'
            </div>
        </div>
    </div>
    </div> <!-- End Game Container -->

    <script>
        /* ===========================
           DATA & CONFIG
           =========================== */

        let CONFIG = null;

        const RING_TEETH = 24;
        const GEAR_TEETH = 16;
        const GEAR_STEP = 360 / GEAR_TEETH;
        const RING_STEP = 360 / RING_TEETH;

        // Game State
        let state = {
            gearAngle: 0,
            ringAngle: 0,
            gearTick: 0,
            ringTick: 0,
            gearIndex: 0,
            ringIndex: 0,
            roundStarted: false,
            canSubmit: false,
            score: 0,
            attempts: 0,
            selectedInnerIdx: null,
            targetGearAngle: 0,
            targetRingAngle: 0,

            // Zoom / Focus State
            zoom: 1.5,        // Start zoomed in
            targetZoom: 1.5,
            ringOpacity: 0,   // Start hidden
            targetRingOpacity: 0
        };

        // Mappings
        let countryToQ = {};
        let countryToA = {};
        let innerItems = [];
        let outerItems = [];

        /* ===========================
           CANVAS & RENDERING
           =========================== */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, minDim;
        let centerX, centerY;
        let scaleFactor = 1; // Not used but good to have

        // Geometry Cache
        let geom = {
            ringOuterR: 0, ringRootR: 0, ringTipR: 0,
            gearRootR: 0, gearTipR: 0,
            gearCenter: { x: 0, y: 0 },
            ringCenter: { x: 0, y: 0 }
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            minDim = Math.min(width, height);
            centerX = width / 2;
            centerY = height / 2;

            // Calculate Gear Geometry
            geom.ringOuterR = minDim * 0.48;
            const ringBandW = minDim * 0.07;
            geom.ringRootR = geom.ringOuterR - ringBandW;
            const toothH = minDim * 0.06;
            geom.ringTipR = geom.ringRootR - toothH - (minDim * 0.0075); // mesh tightness

            const ringPitchR = geom.ringRootR - toothH / 2;
            const gearPitchR = ringPitchR * (2 / 3); // 16/24 ratio

            geom.gearRootR = gearPitchR - toothH / 2;
            geom.gearTipR = gearPitchR + toothH / 2 + (minDim * 0.0075);

            const centerOffset = ringPitchR - gearPitchR;
            // Contact angle 0 degrees (Right side)
            const contactRad = 0;

            geom.ringCenter = { x: centerX, y: centerY };
            geom.gearCenter = {
                x: centerX + centerOffset * Math.cos(contactRad),
                y: centerY + centerOffset * Math.sin(contactRad)
            };

            render();
            updateDomElements(); // Update HTML overlay positions
        }

        window.addEventListener('resize', resize);

        /* ===========================
           ANIMATION LOOP
           =========================== */
        function lerp(start, end, t) { return start * (1 - t) + end * t; }

        let lastTime = 0;
        function loop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Spring/Lerp Physics
            state.gearAngle += (state.targetGearAngle - state.gearAngle) * 0.1;
            state.ringAngle += (state.targetRingAngle - state.ringAngle) * 0.1;

            // Zoom & Opacity Animation
            state.zoom += (state.targetZoom - state.zoom) * 0.05;
            state.ringOpacity += (state.targetRingOpacity - state.ringOpacity) * 0.05;

            render();
            updateUiLogic();
            updateDomElements();

            requestAnimationFrame(loop);
        }

        // ... (Draw functions)
        function polar(r, theta) {
            return { x: r * Math.cos(theta), y: r * Math.sin(theta) };
        }

        function drawExternalGearPath(ctx, cx, cy, rRoot, rTip, numTeeth) {
            const step = (Math.PI * 2) / numTeeth;
            const halfStep = step / 2;

            // Simplistic Involute approximation
            // Tooth thickness at pitch line ~ half pitch
            const toothWidthAng = halfStep * 0.5;

            ctx.beginPath();
            for (let i = 0; i < numTeeth; i++) {
                const theta = i * step;
                // Root
                ctx.arc(cx, cy, rRoot, theta - halfStep / 2 + 0.05, theta + halfStep / 2 - 0.05);

                // Tooth Up
                const p1 = polar(rRoot, theta + halfStep / 2 - 0.05);
                const p2 = polar(rTip, theta + halfStep / 2 + 0.05);
                const p3 = polar(rTip, theta + step - halfStep / 2 - 0.05);
                const p4 = polar(rRoot, theta + step - halfStep / 2 + 0.05);

                ctx.lineTo(p2.x, p2.y);
                ctx.arc(cx, cy, rTip, theta + halfStep / 2 + 0.05, theta + step - halfStep / 2 - 0.05);
                ctx.lineTo(p4.x, p4.y);
            }
            ctx.closePath();
        }

        function drawInternalTooth(ctx, cx, cy, rRoot, rTip, numTeeth) {
            // For internal gear (ring), teeth point INWARDS
            // rRoot is Outer radius of gap? No.
            // Usually defined: Radius of Tips (smaller) and Radius of Roots (larger)

            // Actually, the Ring Body is drawn as a thick annulus up to rRoot.
            // We need to cut 'negative' teeth or add 'positive' teeth pointing in?
            // Implementation: We draw the blue teeth ON TOP of the ring background.
            // Triangle / Trapezoid shape.

            const w = rRoot - rTip;
            ctx.beginPath();
            ctx.moveTo(rRoot, -minDim * 0.015);
            ctx.lineTo(rTip, -minDim * 0.005);
            ctx.lineTo(rTip, minDim * 0.005);
            ctx.lineTo(rRoot, minDim * 0.015);
            ctx.closePath();
        }

        function render() {
            if (!CONFIG) return;

            ctx.clearRect(0, 0, width, height);

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(state.zoom, state.zoom);
            ctx.translate(-centerX, -centerY);

            // 1. Draw Outer Ring (Fade in)
            if (state.ringOpacity > 0.01) {
                ctx.globalAlpha = state.ringOpacity;

                ctx.save();
                ctx.translate(centerX, centerY);

                // Ring Body
                ctx.beginPath();
                ctx.arc(0, 0, geom.ringOuterR, 0, Math.PI * 2);
                ctx.arc(0, 0, geom.ringRootR, 0, Math.PI * 2, true);
                const grad = ctx.createLinearGradient(-geom.ringOuterR, -geom.ringOuterR, geom.ringOuterR, geom.ringOuterR);
                grad.addColorStop(0, '#2E65B8');
                grad.addColorStop(0.5, '#8AC7FF');
                grad.addColorStop(1, '#1E56A8');
                ctx.fillStyle = grad;
                ctx.fill();

                // Internal Teeth (Ring)
                // Use rotOffset for mesh
                const ringStepRad = (2 * Math.PI) / RING_TEETH;
                // Correct mesh: Ring angle + offset. 
                // We want 0-deg contact to be mesh point?
                // The previous logic had 10-deg contact.
                // Let's stick to standard math: active contact is at 0 (Right).

                const rotOffset = (state.ringAngle + RING_STEP / 2) * (Math.PI / 180);

                ctx.fillStyle = '#1565C0';
                for (let i = 0; i < RING_TEETH; i++) {
                    const theta = i * ringStepRad + rotOffset;
                    ctx.save();
                    ctx.rotate(theta);
                    drawInternalTooth(ctx, 0, 0, geom.ringRootR, geom.ringTipR, RING_TEETH);
                    ctx.fillStyle = '#1565C0';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = minDim * 0.002;
                    ctx.stroke();
                    ctx.restore();
                }

                // Bolts
                ctx.fillStyle = '#B0C9DC';
                for (let i = 0; i < 12; i++) {
                    const a = (i * 30) * (Math.PI / 180);
                    const r = (geom.ringOuterR + geom.ringRootR) / 2;
                    ctx.beginPath();
                    ctx.arc(r * Math.cos(a), r * Math.sin(a), minDim * 0.005, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }

            // 2. Draw Inner Gear
            // Gear Center: Previously offset for 10deg contact. Now we want Right Side (0deg)
            // But if we want the gear centered on screen when zoomed... 
            // The logic: geom.gearCenter is fixed.
            // If we want zoom focus on the gear, we scale around the center.

            ctx.save();
            ctx.translate(geom.gearCenter.x, geom.gearCenter.y);
            ctx.rotate(state.gearAngle * (Math.PI / 180));

            // Shadow
            ctx.save();
            ctx.translate(minDim * 0.005, minDim * 0.005);
            drawExternalGearPath(ctx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();
            ctx.restore();

            // Gear Body
            drawExternalGearPath(ctx, 0, 0, geom.gearRootR, geom.gearTipR, GEAR_TEETH);
            const gearGrad = ctx.createRadialGradient(0, 0, geom.gearRootR * 0.5, 0, 0, geom.gearTipR);
            gearGrad.addColorStop(0, '#FFE082');
            gearGrad.addColorStop(1, '#FF8F00');
            ctx.fillStyle = gearGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.45)';
            ctx.lineWidth = minDim * 0.003;
            ctx.stroke();

            // Inner Hub (Grey) - CLICKABLE
            const boreR = geom.gearRootR * 0.55;
            ctx.beginPath();
            ctx.arc(0, 0, boreR, 0, Math.PI * 2);
            const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, boreR);
            // Highlight hub when ready to click?
            if (!state.roundStarted && state.zoom > 1.2) {
                hubGrad.addColorStop(0, '#B0BEC5'); // Lighter
                hubGrad.addColorStop(1, '#546E7A');
            } else {
                hubGrad.addColorStop(0, '#95A5AE');
                hubGrad.addColorStop(1, '#3A454B');
            }
            ctx.fillStyle = hubGrad;
            ctx.fill();

            // Hub Text "TAP" if zoomed
            if (!state.roundStarted && state.zoom > 1.2) {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = `bold ${minDim * 0.04}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("TAP", 0, 0);
                ctx.font = `bold ${minDim * 0.02}px Inter`;
                ctx.fillText("TO CONFIRM", 0, minDim * 0.03);
            } else {
                // Bolts normally
                ctx.fillStyle = '#263238';
                for (let k = 0; k < 6; k++) {
                    const a = (k * 60) * (Math.PI / 180);
                    const bx = boreR * 0.7 * Math.cos(a);
                    const by = boreR * 0.7 * Math.sin(a);
                    ctx.beginPath();
                    ctx.arc(bx, by, minDim * 0.006, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 3. Draw Inner Text
            // ... (Text drawing logic same, just change angle offset if needed?)
            // We want text readable at 0 degrees (Right)

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const fontSize = Math.max(12, minDim * 0.024);
            ctx.font = `bold ${fontSize}px Inter`;
            const textR = geom.gearRootR * 0.82;
            const gearStepRad = (2 * Math.PI) / GEAR_TEETH;

            innerItems.forEach((label, i) => {
                const theta = i * gearStepRad;
                const x = textR * Math.cos(theta);
                const y = textR * Math.sin(theta);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(theta);

                const globalDeg = (state.gearAngle + (i * 360 / GEAR_TEETH)) % 360;
                let normDeg = globalDeg < 0 ? globalDeg + 360 : globalDeg;

                // Flip logic for readability
                if (normDeg > 90 && normDeg < 270) {
                    ctx.rotate(Math.PI);
                }

                ctx.fillStyle = '#003366';
                ctx.fillText(label, 0, 0);
                ctx.restore();
            });

            ctx.restore(); // End Gear

            ctx.restore(); // End Zoom Scale
        }

        // ... updateDomElements (Uses state.zoom to scale positions?)
        // Actually, CSS transform for HTML elements (Pills) needs to handle zoom?
        // Or we just zoom the canvas and keep HTML elements on top?
        // If we zoom canvas, the coordinate system changes.
        // We probably need to apply zoom to DOM element positions too.

        function updateDomElements() {
            if (!minDim) return;

            // Background Stickers (Parallax or static? Static for now)
            // ...

            // Flag Pills - need to match zoomed coordinate system?
            // If canvas is scaled via ctx.scale, visual is zoomed.
            // HTML elements are independent.
            // We must project the zoomed coordinates to screen coordinates.

            // Scale center: centerX, centerY
            // ScreenX = centerX + (WorldX - centerX) * zoom
            // ScreenY = centerY + (WorldY - centerY) * zoom

            const radius = geom.ringTipR * 1.35;
            const ringPitch = (2 * Math.PI) / RING_TEETH;
            const phaseOffset = (state.ringAngle + RING_STEP / 2 + 4 + RING_STEP / 2) * (Math.PI / 180);

            flagElements.forEach((el, i) => {
                if (state.ringOpacity < 0.1) {
                    el.style.opacity = '0';
                    return;
                }
                el.style.opacity = state.ringOpacity;

                const theta = i * ringPitch + phaseOffset;
                // World Coords
                const wx = geom.ringCenter.x + radius * Math.cos(theta);
                const wy = geom.ringCenter.y + radius * Math.sin(theta);

                // Screen Coords
                const sx = centerX + (wx - centerX) * state.zoom;
                const sy = centerY + (wy - centerY) * state.zoom;

                el.style.left = sx + 'px';
                el.style.top = sy + 'px';
                el.style.transform = `translate(-50%, -50%) scale(${state.zoom})`; // Also scale the pill? Or keep clear?
                // Keeping scale(1) looks cleaner usually, but strictly speaking it should zoom.
                // Let's keep scale(1) for readability unless it overlaps.
            });
        }

        /* ===========================
           LOGIC updates
           =========================== */
        function updateUiLogic() {
            // Active Item at 0 degrees (Right)
            const contactDeg = 0;
            const gearPitch = 360 / GEAR_TEETH;

            let normGear = state.gearAngle % 360;
            if (normGear < 0) normGear += 360;

            // at 0 deg: angle + i*pitch = 0  => i*pitch = -angle
            // Invert logic:
            // The item at 0 degrees is the one where (i * step + currentAngle) % 360 ~= 0
            // i * step = -currentAngle
            // i = -currentAngle / step

            const rawIdx = (contactDeg - state.gearAngle) / gearPitch;
            let idx = Math.round(rawIdx) % GEAR_TEETH;
            if (idx < 0) idx += GEAR_TEETH;

            const activeItem = innerItems[idx];

            if (!state.roundStarted) {
                // Updating UI
                document.getElementById('q-text').innerText = countryToQ[activeItem] || activeItem;
                state.activeInnerLabel = activeItem;
                state.activeInnerIdx = idx;

                // Selection Box Logic
                // It should be at geom.gearCenter.x + geom.gearRootR, geom.gearCenter.y
                // Scaled by Zoom!

                const box = document.getElementById('selection-box');
                const dist = Math.abs(rawIdx - Math.round(rawIdx));

                if (dist < 0.1) {
                    // Coordinates in World Space
                    const wx = geom.gearCenter.x + geom.gearRootR; // Right edge
                    const wy = geom.gearCenter.y;

                    // To Screen Space
                    const sx = centerX + (wx - centerX) * state.zoom;
                    const sy = centerY + (wy - centerY) * state.zoom;

                    box.style.display = 'block';
                    // Box size also depends on zoom? or fixed UI?
                    // Let's keep it consistent.
                    box.style.width = (160 * state.zoom) + 'px';
                    box.style.height = (60 * state.zoom) + 'px';
                    box.style.left = (sx - (80 * state.zoom)) + 'px'; // Centered on Right Edge? 
                    // Wait, right edge is x+R. Box center should be there?
                    // Or box should contain the text? Text is inside.
                    // Text R = 0.82 * R.
                    // Box should be around 0.85 * R?

                    const textR = geom.gearRootR * 0.88;
                    const tx = geom.gearCenter.x + textR;
                    const screenTx = centerX + (tx - centerX) * state.zoom;

                    box.style.left = (screenTx - (80 * state.zoom)) + 'px';
                    box.style.top = (sy - (30 * state.zoom)) + 'px';

                } else {
                    box.style.display = 'none';
                }
            } else {
                document.getElementById('selection-box').style.display = 'none';
            }
        }

        function handleClick(x, y) {
            // Check Hub Click first
            const dx = x - geom.gearCenter.x;
            const dy = y - geom.gearCenter.y;
            const dist = Math.hypot(dx, dy);

            if (dist < geom.gearRootR * 0.55) {
                // Hub Clicked!
                if (!state.roundStarted) {
                    // CONFIRM SELECTION -> Start Zoom Out
                    state.roundStarted = true;
                    state.targetZoom = 1.0;          // Zoom Out
                    state.targetRingOpacity = 1.0;   // Fade In Outer

                    document.getElementById('hint-box').style.opacity = '0';
                    document.getElementById('score-panel').classList.remove('hidden');
                    updateScore();

                    // Recalculate match?
                    state.selectedInnerIdx = state.activeInnerIdx;
                }
                return;
            }

            if (state.roundStarted) return;

            // Text Click Logic (Drag-to-rotate)
            // ... (Existing click logic, updated for 0 deg?)

            const clickAngle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Normalize everything
            let normalizedGearAngle = state.gearAngle % 360;
            if (normalizedGearAngle < 0) normalizedGearAngle += 360;

            let normalizedClick = clickAngle;
            if (normalizedClick < 0) normalizedClick += 360;

            const step = 360 / GEAR_TEETH;
            let targetI = (normalizedClick - normalizedGearAngle) / step;
            let i = Math.round(targetI);
            i = ((i % GEAR_TEETH) + GEAR_TEETH) % GEAR_TEETH;

            if (i >= 0 && i < GEAR_TEETH) {
                rotateToIndex(i);
            }
        }

        function rotateToIndex(idx) {
            // Target: We want item 'idx' to be at 0 DEGREES (Right)
            // i * step + TargetGearAngle = 0
            // TargetGearAngle = -i * step

            const step = 360 / GEAR_TEETH;
            let targetG = -idx * step; // Simple!

            let current = state.gearAngle;
            let diff = targetG - current;
            diff = diff % 360;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;

            state.targetGearAngle = current + diff;
            state.targetRingAngle = state.ringAngle + diff * (2 / 3);
        }

        function snapToGrid() {
            // Optional: Snap to nearest gear tooth alignment
            // Not strictly required but feels nicer.
            const step = 360 / GEAR_TEETH;
            const current = state.gearAngle;
            const remainder = current % step;
            // Snap logic... maybe later if user asks.
        }

        let flagElements = [];

        function createFlagPills() {
            const container = document.getElementById('flags-container');
            container.innerHTML = '';
            flagElements = [];

            outerItems.forEach((flag, i) => {
                const el = document.createElement('div');
                el.className = 'flag-pill';
                el.innerHTML = `<span class="flag-emoji">${flag}</span>`;
                container.appendChild(el);
                flagElements.push(el);
            });
        }

        function initInteraction() {
            let isDragging = false;
            let lastX = 0, lastY = 0;

            const handleStart = (x, y) => {
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;
                if (Math.hypot(dx, dy) < geom.gearTipR * 1.2) {
                    isDragging = true;
                    lastX = x;
                    lastY = y;
                    handleClick(x, y);
                }
            };

            const handleMove = (x, y) => {
                if (!isDragging) return;
                const dx = x - geom.gearCenter.x;
                const dy = y - geom.gearCenter.y;
                const angle = Math.atan2(dy, dx);

                const prevA = Math.atan2(lastY - geom.gearCenter.y, lastX - geom.gearCenter.x);
                let delta = angle - prevA;

                if (delta > Math.PI) delta -= Math.PI * 2;
                if (delta < -Math.PI) delta += Math.PI * 2;

                // Apply rotation
                state.targetGearAngle += delta * (180 / Math.PI);
                state.targetRingAngle += delta * (180 / Math.PI) * (2 / 3);

                lastX = x;
                lastY = y;
            };

            const handleEnd = () => { isDragging = false; };

            canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', e => {
                if (e.touches.length > 1) return;
                const t = e.touches[0];
                handleStart(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchmove', e => {
                if (!isDragging) return;
                e.preventDefault();
                const t = e.touches[0];
                handleMove(t.clientX, t.clientY);
            }, { passive: false });

            window.addEventListener('touchend', handleEnd);

            // Key Controls
            window.addEventListener('keydown', e => {
                const step = 360 / GEAR_TEETH;
                if (e.key === 'ArrowRight' || e.key === 'd') {
                    state.targetGearAngle -= step;
                    state.targetRingAngle -= step * 0.666;
                }
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    state.targetGearAngle += step;
                    state.targetRingAngle += step * 0.666;
                }
                if (e.key === 's' || e.key === ' ') {
                    // Simulate Center Click or verify?
                    // For now just existing logic or ignore
                }
            });
        }

        // Init
        async function initGame() {
            initInteraction(); // Enable controls
            try {
                const response = await fetch('flags.json');
                CONFIG = await response.json();

                // Initialize Mappings
                countryToQ = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.question]));
                countryToA = Object.fromEntries(CONFIG.qas.map(i => [i.key, i.answer]));
                innerItems = CONFIG.innerOrder;

                // Pad outer flags
                outerItems = [...CONFIG.outerFlags];
                while (outerItems.length < RING_TEETH) outerItems.push("");
                outerItems = outerItems.slice(0, RING_TEETH);

                // Initialize DOM pills
                createFlagPills();

                // Start
                resize();
                requestAnimationFrame(loop);
            } catch (error) {
                console.error("Failed to load game configuration:", error);
                document.getElementById('q-text').innerText = "Error loading game data.";
            }
        }

        initGame();
    </script>
</body>

</html>
